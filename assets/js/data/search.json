[ { "title": "自宅の Raspberry Pi で立てているサービスを Cloudflare Zero Trust で公開する", "url": "/posts/cloudflare-zero-trust.html", "categories": "Technology, Network", "tags": "Network, Product, Pomodoro", "date": "2023-04-01 00:00:00 +0900", "snippet": "動機前回記事 までで、自宅鯖で動く生活管理用のタイマーを完成させることができた。末尾に記したように外出先からアクセスできないという問題点があるため、Raspberry Pi の local で動かしているサービスを外部に公開できないかと考えていた。May 5, 2023IP アドレス固定するのとかポートフォワーディングするのとか大変だしリスクも高いしなあ～と思ってダラダラ Twitter を見ていたら上記が流れてきたので、今回は Cloudflare Zero Trust を使って自宅鯖のサービス公開を試してみることとする。CloudFlare Zero Trust とはCloudFlare Zero Trust は、CloudFlare が提供するゼロトラスト型のアクセス制御サービスであり、クラウド型の VPN サービスとして用いることができる。ローカルに立てたサーバに tunnel を導入することによって、インターネット側からアクセスできるようにする ngrok 的なものである。公式サイトの画像が分かりやすい。さらに、単なるクラウド VPN サービスと違って Cloudflare Access を用いたアクセス制御が可能であるため、ユーザーごとにアクセスできるサービスを制限することができる。今回やりたいことは以下のような感じ。 RaspberryPi 上で cloudflared を用いて tunnel を作成。ローカルで動いているサービスにインターネットからアクセスできるようにする。 このままでは全世界の誰でもアクセスできてしまうので、Cloudflare Access を用いてアクセス制御を行う。具体的には、Google を Identity Provider として、自分の Google アカウントでログインしている人しかアクセスできないようにする。大体公式 Ref の手順に従えばよいが、以下ログ的に今回の作業の流れをまとめておく。Cloudflare の事前準備まず Cloudflare にログインしたうえで、Zero Trust の Free Plan に申し込む。ユーザ 50 人までは無料で利用できるらしい、慈善事業か？Cloudflare の Domain Registrationまず Cloudflare にログインしたうえでダッシュボードの「Domain Registration」から、自分のドメインを登録する必要がある。Cloudflare Zero Trust では、例えば hoge.com というドメインを持っていた場合、サービスは test.hoge.com というようにサブドメインを用いて公開することになるため、Cloudflare の DNS に登録できるドメインを用意する必要がある。他サービスで取得したドメインの DNS 設定を Cloudflare に移行しようとするとなかなか大変であるが (こちら を参照)、このあたりの作業はそもそも Cloudflare Register でドメインを新規取得することで大幅に楽になる。今回はちょうど ternbusty.com を取っておきたかったこともあり、潔く新規登録することにした。Raspeberry Pi の設定まず Cloudflared のインストール &amp;amp; ログイン。このあたりの一連の手順については 公式 Ref を参照。wget https://github.com/cloudflare/cloudflared/releases/download/2023.5.0/cloudflared-linux-armhf.debsudo apt install ./cloudflared-linux-armhf.debcloudflared tunnel login適当な名前 (ここでは test) のトンネルを作成。標準出力される credentials file のパス名を控えておく。また、list コマンドを用いて tunnel ID を確認しておく。cloudflared tunnel create testcloudflared tunnel list次に、控えておいた tunnel ID を用いて ~/.cloudflared/config.yml を以下のように編集する。今回は http://localhost:3000 を test.ternbusty.com に公開するので以下のようになる。ingress ルールについては こちら を参照。hostname と service の組を複数記載し、同じサーバ上で動いている別のサービスを一緒にマッピングすることもできる。tunnel: xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxcredentials-file: /home/ternbusty/.cloudflared/xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxx.jsoningress: - hostname: test.ternbusty.com service: http://localhost:3000 - service: http_status:404続いて DNS の設定を行う。cloudflared tunnel route dns &amp;lt;UUID or NAME&amp;gt; &amp;lt;hostname&amp;gt; のようにすれば サブドメイン test について CNAME が設定される。コマンド実行後、Cloudflare のダッシュボードにある DNS -&amp;gt; Records を見ると、CNAME として test が追加されたのが確認できる。cloudflared tunnel route dns test test最後に実行。これにより、test.ternbusty.com にアクセスできるようになる。cloudflared tunnel run testCloudflare Access の設定Google でのログインを追加このままでは全人類にアクセスされてしまうので、Cloudflare Access を用いてアクセス制御を行う。基本的には 公式 Ref に従えばよい。まずは Google の方の設定から。 GCP を開いて新規プロジェクトを作成。APIs &amp;amp; Services -&amp;gt; Credentials -&amp;gt; Configure Consent Screen で各種設定を行う。User Type は External にしておく。 APIs &amp;amp; Services -&amp;gt; Credentials -&amp;gt; Create Credentials -&amp;gt; OAuth Client ID で OAuth Client ID を作成する Application Type: Web Application Authorized JavaScript origins: 今回は https://ternbusty.com Authorized redirect URIs: 今回は https://ternbusty.cloudflareaccess.com/cdn-cgi/access/callback 続いて、Cloudflare 側の設定を行う。Zero Trust -&amp;gt; Setting -&amp;gt; Authentication -&amp;gt; Login methods -&amp;gt; Add new から Google を選択し、先ほど作成した App ID と Client secret を入力する。これで Google アカウントでのログインができるようになる。Application の設定Zero Trust -&amp;gt; Access -&amp;gt; Applications -&amp;gt; Add an application から新規アプリケーションを作成する。今回は Raspberry Pi 上で動いているサービスを test.ternbusty.com というサブドメインで公開するので、以下のように設定する。 Select type Application type: Self-hosted を選択 Configure app Application name, Session Duration: 任意に設定 Application domain: test.ternbusty.com を指定する。Domain は Cloudflare の DNS に登録されているものをプルダウンで選ぶ形式。 Enable App in App Launcher: Disable Identity providers: Accept all available providers を無効にし、Google のみを指定 Add policies Policy name は任意に設定。Action は Allow としておく。 Configure rules は Emails を選択したうえで、Value には自分の Google アカウントのメールアドレスを入力する。 以上の設定を終えたうえで test.ternbusty.com にアクセスしてみると、以下のようにログイン画面が表示される。いい感じ。ここで自分のアカウントでログインしてみると当然サービスが利用できるし、試しに別垢でログインを試みたところ「That account does not have access」と表示されて失敗する。やったね！トラブルシューティング cloudflared tunnel run した際に failed to sufficiently increase receive buffer size. が表示される問題。これについては、リンク先の instruction 通り buffer size を増やせばよい。sudo sysctl -w net.core.rmem_max=2500000 同じく cloudflared tunnel run した際に Incoming request ended abruptly: context canceled が大量発生する問題。要はタイムアウトしているということだと思うが、手元の環境では実行時に IPv6 を指定することで改善した。cloudflared tunnel --edge-ip-version 6 run test感想今回、Cloudflare zero trust を利用することによって、自宅鯖それ自体を外部に公開することなくインターネットから利用し、さらに Google アカウントを用いたアクセス制御を行うことができた。Cloudflare Zero Trust はユーザ数が 1 人なので無料プランのままで利用できるし、かかっているコストは Cloudflare で新規取得したドメインの料金くらいである (これに関してはもともと取りたかったドメインだし、年間 1400 円くらいなので別にいいかな)。自宅鯖で動かしている自分用のサービス (今回の例では自分用タイマー、冒頭の例では Grafana) にインターネットからアクセスしたい場合 Cloudflare zero trust はかなり有力な選択肢と考えられる。今後もインターネットから利用したいサービスを自作した場合は積極的に利用していきたい。" }, { "title": "ポモドーロ変法タイマーの実装 (3)", "url": "/posts/modified-pomodoro-3.html", "categories": "Technology, Web", "tags": "JavaScript, Python, Product, Pomodoro", "date": "2023-03-01 00:00:00 +0900", "snippet": "動機前回記事 では、ポモドーロタイマーを家の Raspberry Pi で作動させるようにしたうえで、休憩を長く取りすぎていると鬼電がかかってくるようにした。今回は、前回記事に課題として記した タイマーを work モードにしたまま、SNS を閲覧するなど怠惰な時間を過ごしてしまう そもそもタイマーを開始するのを忘れるの 2 点を解決していく。具体的には、 タイマーで休憩中になっているタイミング以外は、Windows PC やスマートフォンで Twitter や Discord を閲覧できないようにする 帰宅 or 起床したタイミングでタイマーをスタートさせ、外出 or 就寝するタイミングでタイマーをストップさせる機能を追加することとする。方法休憩中以外には Twitter と Discord を閲覧できないようにするPC と iPhone 上で適宜タイマーの状態を取得し、SNS 閲覧不可と判定された場合は閲覧制限を発動、可能と判定された場合は制限を解除する方針とした。SNS を閲覧してよい条件は、is_lazy が False であり、かつタイマーの status が break である場合に限定することとした。PC で Twitter と Discord の閲覧制限をかけるこれについては、以前 別の場所 で書いたように firewall を弄ることにより実現可能である。つまり、Twitter の Net Range 104.244.40.0 - 104.144.46.255 と Discord の Net Range 162.158.0.0 - 162.159.255.255 をブロックすればいいわけである。まずは、Windows の firewall 設定を開き、この記事 の要領で新しい規則を設定する。次に、この規則を自動で ON/OFF する Python スクリプトで書く。管理者権限で実行する必要があることに注意が必要。import requestsimport jsonimport subprocessimport sysPOMODORO_URL = &quot;http://192.168.11.11:8080/&quot;def get_status() -&amp;gt; str: try: res: requests.models.Response = requests.get(POMODORO_URL + &quot;status/&quot;) status: str = json.loads(res.text)[&quot;status&quot;] return status except BaseException: return &quot;Something is wrong&quot;def is_lazy() -&amp;gt; bool: try: is_lazy_str: str = requests.get(POMODORO_URL + &quot;is_lazy/&quot;) is_lazy_bool: bool = True if is_lazy_str == &quot;true&quot; else False return is_lazy_bool except BaseException: return Truedef block_twitter() -&amp;gt; None: subprocess.run([&quot;netsh&quot;, &quot;advfirewall&quot;, &quot;firewall&quot;, &quot;set&quot;, &quot;rule&quot;, &quot;name=block_twitter&quot;, &quot;new&quot;, &quot;enable=Yes&quot;])def unblock_twitter() -&amp;gt; None: subprocess.run([&quot;netsh&quot;, &quot;advfirewall&quot;, &quot;firewall&quot;, &quot;set&quot;, &quot;rule&quot;, &quot;name=block_twitter&quot;, &quot;new&quot;, &quot;enable=No&quot;])if __name__ == &quot;__main__&quot;: status: str = get_status() if status == &quot;break&quot;: if not is_lazy(): print(&quot;You can use Twitter!&quot;) unblock_twitter() sys.exit() block_twitter()次に、上記のスクリプトが 1 分おきに実行されるようにタスクスケジューラを設定する。特に工夫をしないと 1 分おきにコマンドプロンプトの黒いウィンドウが出現するようになり非常に鬱陶しいので、この記事 を参考に Python スクリプトを走らせるバッチを作成し、さらにそれを VBScript から実行させることにより解決した。C:/Users/ternbusty/AppData/Local/Programs/Python/Python310/python.EXE E:/Dropbox/sandbox/block_twitter_discord.pySet ws = CreateObject(&quot;Wscript.Shell&quot;)ws.run &quot;cmd /c &quot; &amp;amp; Wscript.Arguments(0), vbhideiPhone で Twitter と Discord の閲覧制限をかける私の知る限り、iOS 上で直接 firewall を弄る機能は提供されていない。そのため、iOS のオートメーション機能をフル活用し、Twitter と Discord 2 つのネイティブアプリケーションに利用制限をかけることにした。つまり、 トリガー: 2 つのアプリのいずれかが開かれたとき アクション: 家の Wi-Fi につながっており、かつタイマー上休憩をしてはならない時間帯と判定された場合は、自動的に他のアプリケーション (ToDo リストアプリなど) にリダイレクト (+ タイマーが止まっていればスタート) させる。ようにした。こんなのがノーコードでできるんだからよい時代である。適切なタイミングでタイマーをスタートさせる帰宅を検知して自動でタイマーをスタートさせるおそらく一番楽なのは、iPhone のオートメーション機能で「Wi-Fi に接続したとき」をトリガーにすることだが、携帯を引っ張り出しロックを解除し通知をわざわざタップして……というのはあまりに面倒すぎる。他の解決策としては、以下のものを考えた。 帰宅や出勤時に押せるような IoT ボタンを玄関に設置する 以前作成した Wi-Fi 打刻システム を利用するこのうち 1 については試しにやってみて概ねうまく行くことが分かった (別記事参照)。が、今回使用したダイソーの Bluetooth Shutter は 60 秒程度でスリープに入ることが知られており、ボタンをトリガーとして何らかの動作を実現させるには、まず適当なボタンを押してから 5 秒ほどあけて再度押下するというかなりエレガントさに欠ける動作をしなくてはならない。照明の消灯 / 点灯と組み合わせることによってボタンを押すモチベーションを保とうともしてみたが、この動作を外出と帰宅の度に繰り返すのはさすがにやってられんという結論に達した。以上より、今回は 2 の方法を採用することとした。具体的には、この記事 で書いたスクリプトを編集し、iPhone が Wi-Fi に接続されたタイミングで /start/ を、接続が切れたタイミングで /pause/ を叩くように改変し、無事所望の動作が実現できるようになった。if file_exist: if self.status != &#39;in&#39;: send_to_slack(f&#39;:arrow_right: in: {dt_str}&#39;) self.status = &#39;in&#39; try: requests.put(&quot;http://localhost:8080/start/?break_time=900&quot;) except: print(&quot;Cannot restart timer&quot;)else: if self.status != &#39;out&#39;: send_to_slack(f&#39;:arrow_left: out: {dt_str}&#39;) self.status = &#39;out&#39; try: requests.put(&quot;http://localhost:8080/pause/&quot;) except: print(&quot;Cannot pause timer&quot;)起床後すぐにタイマーをスタートさせる起床そのものを検知するのはウェアラブルモニタでも着けていないかぎり不可能である。ここでは、起きてすぐ時刻の確認ついでにまず SNS をチェックする癖があることを利用して「家の Wi-Fi につながっており、かつタイマーがスタートしていない状態で Twitter あるいは Discord を開く」を起床の定義とした。前節でこれはすでに実装済みであるため、起床と概ね同時にタイマーをスタートさせることが可能となった。今後の課題今回の実装で、家の中にいる際の動作については満足のいくものを作ることができた。今後改善が必要なのは外出時における操作である。本プロダクトはプライベートネットワーク上の HTTP 通信を用いてタイマーの起動やモードの切り替えを行っているため、当然勤務先でタイマーを使うことはできない。そればかりか、この間はうっかりタイマーを break モードのまま止め忘れて外出したせいで lazy モードに突入し、外出先で CallMeBot から繰り返し電話がかかってくるという致命的な事態が発生した (外出は 5 分以内に検知され pause されるものの、それでも誤作動すると厄介である)。家のネットワーク以外からでもタイマーの操作ができるようにする方法としては、 家に VPN サーバを立てて公開することにより、外出先からプライベートネットワークにアクセスする。まず VPN に対応したルータを買い、グローバル IP アドレスを固定し、ポートを開け、セキュリティ対策をし……となると、勉強にはなりそうだがコストとリスクがすごそうだなという印象。 remote.it の Persistent Public URL を利用する。これにより、192.168.11.11 の代わりに、ランダムな文字列を含む不変の public URL でアクセスができるようになる。このまま放置すると当然 URL を知っている他人から私の作業履歴が見えたりタイマーを操作されたりといった事態が発生するので、何らかの方法でアクセス制限をかけたいところ。せっかく FastAPI を使っていることだし、自分しか認証しない OAuth2 とか導入してみるのもいいかも？くらいだろうか。物理出社が増えてきたタイミングで実装を検討したい。" }, { "title": "ポモドーロ変法タイマーの実装 (2)", "url": "/posts/modified-pomodoro-2.html", "categories": "Technology, Web", "tags": "JavaScript, Python, Product, Pomodoro", "date": "2023-02-01 00:00:00 +0900", "snippet": "動機前回記事 ではブラウザ上で動くポモドーロ変法 (筆者が勝手に命名した) を実装したわけだが、末尾に課題として記したように 端末自体がスリープされるとカウントダウン自体がストップしてしまう 休憩可能時間をオーバーした際、アラームが鳴っていたとしても離席中やそもそもブラウザを開いていないタイミングでは気づくことができないという問題が残っていた。本稿では上記の点の改善として、 ブラウザ上でタイマーを管理するのをやめ、家で常時電源に接続されている RaspberryPi で動作させるようにする 休憩可能時間をオーバーした際、スマートフォンに電話がかかってくるようにする。一定時間 (今回は 90 秒) 経過してもまだ休憩している際は繰り返し電話をかけることにより解決をはかることにした。これにより、ダラダラしている (つまり、休んでいい時間を超過して休んでしまっている) と「はやくなんかしろ」という意味を込めた戒めの鬼電が 90 秒おきにかかってくるようになるわけである。完成したものは こちら。方法タイマーを RaspberryPi 上に移植する まずはタイマーそのものをバックエンドで動かすことにした。フレームワークはなんでもよかったのだけど、個人的に興味のあった FastAPI と、フロントエンドは前回のコードを流用し生 JavaScript で書いた。 タイマーの残り時間やタスクの履歴はすべてバックエンドで管理する方針とした。一応タイマーなのでフロントエンドの方では 1 秒おきに表示を更新したいものの、バックエンドに対して 1 秒おきにリクエストを送って同期するのもそれはそれでどうなんだというところではある (いいアイデアがあったら誰か教えてください)。結局、フロントエンドの方では前回記事同様自律的に ticktock してタイマーが動いている雰囲気を出していただき、適宜バックエンドと同期して表示を更新するような実装になった。 FastAPI さんが自動生成してくれた document を以下に載せておく。 状態の取得 タイマーの状態 (status) は not_started, work, break, finished, pause の 5 種類とし、タイマーの残り時間やタスクの名前も合わせて /status/ で取得できるようにした。 休憩タイマーが負の値になっている (つまり、休憩可能時間を過ぎて休憩してしまっている) 状態を lazy と定義し、/is_lazy/ で lazy かどうかの bool を返す方針とした。 食事休憩を考慮して Take a 30 min break というボタンをフロントエンド側で用意しているのだが、むやみに押されると困るので、一度実行されたら 6 時間は can_take_long_break が偽を返すようにしておいた。長い休憩を取ろうとした際にこれが偽だと拒否される設計。 タイマーの操作 PUT を用いてタイマーの status を切り替えるようにした。これ PUT でよかったのか？ 普通に while 文とかを用いて ticktock させる処理を書くと、タイマーをスタートさせる start への応答が終了していないとみなされてハングしまうため、以下のように background で動作させる方針とした。 @app.put(&quot;/start/&quot;)async def start(background_tasks: BackgroundTasks, break_time: int = 0) -&amp;gt; None: background_tasks.add_task(timer.main, break_time) 既にタイマーが動作している状態で start へアクセスされるとバックグラウンドタスクが二重に起動して時間が二倍の速さで進むようになるため、start へのアクセスがあった場合はタイマーの status を確認し、既に動作しているときは無視する方針とした。 外出などで一時的にタイマーを止めたいとき用に pause メソッドも用意しておいた。 以上を実装したうえで、FastAPI を RaspberryPi 上で起動しておく。リクエストが失敗したときそれを伝える応答も何も用意しておらず API の設計としてやばすぎるが、とりあえず動く用にはなった。 uvicorn main:app --reload --host 0.0.0.0 --port 8080 休憩時間が負の値になったとき自分に電話をかける 長く休憩しすぎている (lazy) であることを自分に気づかせるためにはスマートフォンへ何らかの通知をすることが有効であると考えられ、今回は一番鬱陶しいであろう着信でそれを実現することにした。当初は Twilio を用いて自分の電話番号へ発信することを考えていたが、別に通話がしたいわけでもないのに課金するのもなあという気分になったので、VoIP を実装しておりかつ API を公開している無料のサービスを探すことにした。 この用途にはこちらの API 経由で Telegram Voice Call するサービス がぴったりであった。Telegram のアプリをスマートフォンにインストールしたうえで、CallMeBot を Telegram アカウントで認証すると、ユーザー名を用いてコマンドラインから当該ユーザに Voice Call できるようになる。Reference に明文化されてはいないが、おおよそ 90 秒に一回という API 制限がある模様であった。今回は、90 秒後にもまだ lazy な場合は再度電話を掛けるようにした。 curl &quot;https://api.callmebot.com/start.php?source=auth&amp;amp;user=@username&amp;amp;text=Back+to+work!!&amp;amp;lang=en-US-Standard-B&quot; 上記をそのまま同期処理で行う Python スクリプト内で呼び出すと、電話に対してユーザ (筆者) が応答あるいは拒否するまで Response がないとみなされ処理が終了せず、ticktock がストップするという問題が発生した。これを回避するため、以下のように thread を分けることにより解決した。 if self.break_timer % 90 == 0: try: thread = threading.Thread(target=self.utils.call_me, name=&quot;callMe&quot;) thread.start() except BaseException: print(&quot;Failed to call me&quot;) 今後の課題タイマーで lazy 判定されていれば自分に鬼電をかけられるとはいえ、 根本的な話になるが、タイマーの status を work にしたままダラダラされたら今回の試みは何の意味もなさなくなる。これについては、例えば status が work になっている場合は (ダラダラする元凶であるところの) SNS の閲覧をできないようにするなどの制限が有効かもしれない。 そもそもタイマーを作動させるのを怠ったら終わりである。帰宅したら自動的に、あるいは何らか自然な方法でタイマーをスタートさせる仕組みが必要と考えられる。これには以前構築した Wi-Fi 打刻システムの構築 を利用できるかもしれない。" }, { "title": "ポモドーロ変法タイマーの実装 (1)", "url": "/posts/modified-pomodoro-1.html", "categories": "Technology, Web", "tags": "JavaScript, Product, Pomodoro", "date": "2023-01-01 00:00:00 +0900", "snippet": "動機年末年始は当直で病院に釘付けであったため、この隙を利用して某レポート (55 症例でなんと A4 図無し 110 ページ！) を片づけることとした。が、いかんせん内容があまりにも面白くなさすぎるという問題があり、執筆中に意識散漫になるわ適当な理由をつけてやたら長い休憩を取ってしまうわで集中とは程遠い状態であった。これを改善するために、ネット上でたまたま見かけた作業効率化用テクニック ポモドーロ法 (25 分集中し、その後 5 分休憩するという一連の流れを繰り返す手法) の実践を試みたところ、今度は以下のようなことが分かった。 a. 上記の流れが外的な要因で破壊されたときのリカバリ方法がない。つまり、25 分の作業中に何らかの邪魔が入った場合 (病棟からの電話など) や、やむを得ず 5 分以上の休憩を取ってしまった場合 (知り合いと出くわしたときなど)、最初からやり直すしかなくなり有耶無耶になってしまう b. 気分が乗っているときは 25 分以上集中力が持つので、インターバルが 25 分で区切られているのは逆によろしくない場合がある c. そもそも席についてからポモドーロタイマーをスタートさせるまでに時間がかかる。よし作業をするぞと決意するのが、だらだらネットサーフィンをするなど一通りのんびりした後になってしまうこのうち a や b については、作業や休憩の前借りや借金 (つまり、長めに作業をしたときはそれに応じて休憩可能時間が長くなり、休憩を長くとってしまった分はそれに応じて長めの作業が付与される) を可能にすることにより、最終的に作業と休憩の合計時間比を 5:1 に調整できるのではないかと考えられた。これをポモドーロ変法と名付け、以下で実装を行っていく。完成したものは こちら。ポモドーロ変法概要ポモドーロ法の基本骨格 (25 分作業をすれば 5 分休憩できるようにする) は残しつつ、以下のような仕組みを導入した。オリジナルと異なる部分を下線で示す。 作業タイマーと休憩タイマーの 2 つを用意し、常にどちらか一方がカウントダウンされているようにする。能動的に切り替えない限り、状態は変わらない。 25 分にセットされた作業タイマーが 0 になった瞬間、休憩タイマーに 5 分が加算されるようにする (休憩の貯金)。 2 と同時に作業タイマーが 25 分にリセットされ、カウントダウンを始める。つまり、休憩に移ることなく自動的に次の作業インターバルに突入する。 休憩したくなった場合はモードの切り替えを行う。今度は休憩タイマーのカウントダウンが発生し、2 の手順により貯めた休憩が消費されていく。 休憩を消費しきった場合アラームが鳴るが、以降も休憩をやめなければ休憩タイマーは負の値になっていく (休憩の借金)。 休憩をやめ作業に戻る際、休憩タイマーが負の値を指している場合はその秒数分を作業タイマーに加算した状態で作業タイマーのカウントダウンが発生する。つまり、長めに休んだ分だけ次の作業時間が長くなるという寸法である。これに加え、以下のような工夫を施した。 (上の c で挙げた) デスクについてから、仕事モードに入ってポモドーロタイマーをスタートさせるまでに時間がかかってしまう問題について。タイマーをスタートさせた時点でのデフォルトのモードを休憩 (5 分) とし、カウントダウンを開始することにより解決した。デスクについてからちょっとダラダラしてしまうのは仕方ないが、それを 5 分以内で終わらせなさいよという意図である。 生きている人間には食事が必要であるため、一日中上記のスケジュールに従って仕事をし続けられるわけではない問題について。食事休憩を想定して「休憩タイマーに 30 分追加する」ボタンを設置した。なお、このボタンは一度クリックすると 5 時間は無効になるので、長い休憩をむやみに何回もとることはできない。実装上記を JavaScript で書き、ブラウザから利用できるようにした (コードに興味がある方は こちらをどうぞ)。基本的に JavaScript の入門書にあるような setTimeout を使った至極単純なタイマーなので特に技術的に面白さがあるかといわれれば別にないが、以下のような問題が発生したので都度対処を要した。 タブがアクティブでないと setTimeout がサボられ始める こちらの stackoverflow のスレッドなどで議論がある。これは普通に知らなかったので見事に踏み抜いた。結果的に、Web Worker を利用することによりタイマーが開かれているタブが非アクティブな状態でもカウントダウンを実行することができた (参考)。 タイマーの音がミュートになってしまう Google Chrome では、ユーザが当該ページでクリックやタップなどのアクションを行わない限り音声の自動再生はミュートされる設定になっており (参考) 休憩を消費しきったタイミングでアラームを鳴らさそうにも無音になってしまう現象が発生する。 これを回避するために、(ややトリッキーではあるが) タイマー開始前にユーザにクリックおよび事前の音声再生を強制する仕様とした。具体的には、タイマー開始時に Start today&#39;s job なるそれっぽいボタンをクリックさせ、さらにそのタイミングで適当な音声を流すことにより上記の条件を自動的に満たすようにした。 うっかりページ遷移や更新をしてしまった場合、リセットされてしまう これは現状仕方がないので、ページ遷移のタイミングで警告を出すことによりこのような事故を防止することにした。 つまり、window.onbeforeunload を追記した。 実際に使ってみての感想 上記自作タイマーを使って実際にレポートを何本か書いてみた。単にタイマーを管理するだけでなく、やっているタスクの入力欄を作って作業の履歴が残るように実装してみたのだが、以下はその記録である。不定期に長い作業をしたり休憩を取ったりしつつ作業を進めていることが分かる。本来のポモドーロ法からは大分逸脱したスタイルだ。 これだけだとタスクにかかった時間や休憩時間の実態がよく分からないので、Summarize 機能を追加してその日の時間の使い方を把握できるようにした。上記をまとめると以下のようになり、なんやかんや作業と休憩の比を 5:1 程度に調整できていることが分かった。結果的にレポートも捗ったし、やったね！ ちなみにこのサマリはクリップボードにコピーできるようにしたので、こんな感じで Slack に貼るなりしてその日の作業概要を残しておくことが可能である。これは自分でも結構お気に入りの機能。今後の課題現状上の実装で特に困ってはいないが、今後改良が見込まれると考えられる点を以下に書き残しておく。 端末自体がスリープされるとカウントダウン自体がストップしてしまう 電源接続時は PC を画面ロックするのみでスリープしない設定にしているので現時点では問題ないが、スマートフォンで利用する際には普通に困りそう ブラウザ上の JavaScript を端末のスリープ中に動作させるのは原理的に不可能なので、タイマーの処理に Date 関数を利用する などして経過時間を計算するのが手っ取り早そう 休憩可能時間をオーバーした際、PC でアラームが鳴っていたとしても離席中は気づくことができない 何らかの方法で iPhone の方に通知が飛ぶようにする……？ 何らかの web API を叩くにしても、ブラウザ上でやろうとすると CORS を踏みそう 離席中に気づけなくても構わないように休憩の借金制度を導入しているので、まあこれはこれでいいのではないかという気はする " }, { "title": "YouTube の再生リストをシャッフル / 逆順で再生させる", "url": "/posts/playlist-player.html", "categories": "Technology, Web", "tags": "JavaScript, Product", "date": "2022-12-01 00:00:00 +0900", "snippet": "TL;DR 概要: YouTube のプレイリストをシャッフル再生したり、逆順で再生したりする web サービス (これ) を作った。自分が高評価した動画のリストや非公開プレイリストでも利用できるのが特徴。 環境: 拡張機能 Tampermonkey のインストールが可能なブラウザ (PC 上からの閲覧を想定) 使い方: 拡張機能 Tampermonkey をインストール Userscript をインストール 本ツール にアクセス プレイリスト ID を入力し、Normal (通常再生) か Reverse (逆順) か Random (シャッフル) をクリック スクリーンショット動機作業用 BGM として YouTube で高評価した動画など適当な再生リスト (プレイリスト) をシャッフル再生していることが多いのだが、動画が 200 を超えたあたりからどうやら挙動がおかしくなる (特定の動画の繰り返しでループになってしまう) ことに気づいた。試しに 344 個の動画が登録されているプレイリストをブラウザでシャッフル再生してみたところ、表示される動画のインデックスは以下のような順序となった。1 79 138 197 256 315 340 321 341 323 325 312 340 321 341 323 325 312 340 321 341 323ご覧の通り、動画インデックスが単調増加していったと思えば、340 321 341 323 325 312 という流れの繰り返しに突入してしまい抜け出せなくなっていることが分かった。これをシャッフル再生と呼ぶのはどう考えても無理があるだろう。この問題については既に方々で報告がなされており、公式ヘルプサイトでユーザによる ブチギレ投稿 などもなされているが、数年を経ていまだ Bug Fix には至っていないようだ。これを回避するために、プレイリストの ID を入力するとプレイリストの動画をシャッフル再生してくれるサービス も提供されており、こちらはきちんと再生リスト全体を並べ替えてくれる。公開されている再生リストについてはこのようなサイトを使えばいいとして、非公開のリスト (自分が個人的に作っており特に公開予定がない再生リストや、自分が高評価した動画リスト) をシャッフル再生するためにそれ用のウェブサービスを自作することにした。上記と直接の関係はないが、以前ブラウザ版 YouTube で提供されていた「並べ替え」機能が消失したらしく (これについて公式による情報は見つからず詳細は不明)、プレイリストを逆順に再生することもできなくなっているようである。特定のチャンネルでアップロードされた動画を古い順に再生したいなどの需要は存在すると思われるので、ついでにこれも実装してしまうことにする。実装概略を以下に示す。実装は、JavaScript (ブラウザ + Tampermonkey) により ページに埋め込まれたプレーヤー (IFrame Player) を操作することにした。 プレイリスト内にある動画インデックスをシャッフルした配列を用意する 動画インデックスからどうにかして動画 ID なり URL なりを取得し、それを格納する配列を用意する 2 を順番に再生する動画インデックスの配列を作成するまず 1 を実現するためにはプレイリスト内にある動画の数を把握する必要があるが、これには 2 つの方法が考えられる。 1-1. 普通に YouTube Data API を利用する 1-2. プレイリストのウェブサイトにアクセスし、スクレイピングする1-1 についてはおそらく私が発行した API key を使うことになるが、Rate Limit があるので万が一ユーザが増えた場合大変な事態になること、他ユーザがこのサービスを利用した場合に (当然ながら) 当該ユーザが作成した非公開プレイリストの情報を取得できないこと、などの問題がある。なので今回は 1-2 の方法を採用することにした。1-2 をブラウザ上にて JavaScript を利用して実行すると CORS を踏むので、Tampermonkey を利用してユーザスクリプト (ソースコードは こちら) で行うことにした。function makeGetRequest(url) { return new Promise((resolve, reject) =&amp;gt; { GM.xmlHttpRequest({ method: &quot;GET&quot;, url: url, onload: function(response) { resolve(response.responseText); } }); });}async function getPlaylistLength(playlist_id) { const url = &quot;https://www.youtube.com/playlist?list=&quot; + playlist_id; let res = await makeGetRequest(url); try { let result = /&quot;stats&quot;:\\[{&quot;runs&quot;:\\[{&quot;text&quot;:&quot;(\\d*?)&quot;}/.exec(res); return result[1]; } catch (error) { document.failflag = 1; return undefined; }}動画インデックスから動画 ID を取得する続いて 2 について。プレイリスト再生中の動画 URL は例えば https://www.youtube.com/watch?v=dQ1V3EF6WdA&amp;amp;list=UUlSsb_e0HDQ-w7XuwNPgGqQ&amp;amp;index=210 のようになっており、動画 ID、プレイリスト ID、インデックスの 3 つが含まれている。YouTube のプレイリスト ID と動画インデックスを &amp;amp;index= みたいな形で与えれば勝手にリダイレクトしてくれるんじゃないかと期待していたのだが、https://www.youtube.com/watch?list=UUlSsb_e0HDQ-w7XuwNPgGqQ&amp;amp;index=210 などとしてみてもエラーページに行きつくのみである。これについても 先人の議論 があり、v=+ など動画 ID 部分に適当な一文字を入れて https://www.youtube.com/watch?v=+&amp;amp;list=UUlSsb_e0HDQ-w7XuwNPgGqQ&amp;amp;index=210 などとすると上手いことリダイレクトされることが判明した。よって、これをスクレイピングすることにより動画 ID を取得することにした。前節と同様の理由で、この作業も Tampermonkey 上で行った。async function getVideoID(playlist_id, index){ const url = &quot;https://www.youtube.com/watch?v=+&amp;amp;list=&quot; + playlist_id + &quot;&amp;amp;index=&quot; + index; let res = await makeGetRequest(url); let video_id = /&quot;watchEndpoint&quot;:{&quot;videoId&quot;:&quot;(.*?)&quot;,/.exec(res); return video_id[1];}動画を再生する動画の再生に関しては、YouTube により提供されている IFrame Player API を用いることとした。この API 自体にもプレイリスト内の動画を順番に再生する機能がついているものの、仕様上 200 個の動画しか読み込みできないようなので今回は使用しなかった。Player にイベントリスナーを追加したうえで、動画の再生終了が検知されたタイミングで次の動画を読み込むようにした。ソースコードは こちら。let tag = document.createElement(&quot;script&quot;);tag.src = &quot;https://www.youtube.com/iframe_api&quot;;let firstScriptTag = document.getElementsByTagName(&quot;script&quot;)[0];firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);function onYouTubeIframeAPIReady() { player = new YT.Player(&quot;player&quot;, { height: &quot;360&quot;, width: &quot;640&quot;, events: { onReady: this.onPlayerReady, onStateChange: this.onPlayerStateChange, }, }); document.player = player; player.yts = new YouTubeShuffler();}今後の展望上記によりプレイリストのシャッフルや逆順再生ができるようになった。個人的に特に困ってはいないが、今後の改良点などを書いておく。 ページを再読み込みしたり閉じたりすると一度読み込んだ動画 ID のリストなどが消失する。これについては、公式で提供されているプレイリストシャッフル機能もそのような仕様だしまあええかと思っている。 ブラウザに Tampermonkey をインストールできる環境でしか使うことができない。PC 版の Chrome でしか動作検証をしていないが、どうやら iOS 版の Safari 等でも拡張機能が導入できるようになっており頑張れば Userscript を動かせるようなので、暇なときに試してみたい。" }, { "title": "Wi-Fi 打刻システムの構築", "url": "/posts/wifi-checkin.html", "categories": "Technology, Network", "tags": "Python, Raspberry Pi, Product", "date": "2022-11-01 00:00:00 +0900", "snippet": "概要現在の職場にはいわゆる打刻システムというものがなく、その月にした時間外勤務を月末までにまとめて入力する制度になっている。どの日にどのくらい残業していたのか (≒ 何時に帰宅したか) を把握するために、帰宅を検知しその時刻を記録するシステムを作ることにした。帰宅の検知にはドア開閉の検知や照明のオンオフなどが利用できそうであるが、前者は出勤と帰宅の区別がつかない (勤務時間帯が不規則になりうるのでこれらは明確に弁別したい)、後者については睡眠と出勤の区別がつかない、という問題がある。そこで今回は、出勤の時はだいたい私物の iPhone を持ち歩いているということを踏まえ、iPhone が家の Wi-Fi につながっているか否かによって在宅かどうかを判定することにした。Wi-Fi への接続をどのように検知するか検知の方法としては大きく分けて以下の 2 通りが存在する。 iPhone 上で、自身が接続されているネットワークの情報を取得することにより、在宅かどうかを判定する 自宅ネットワーク上に存在する何らかのサーバ (Raspberry Pi などを想定) 上で、iPhone が同一ネットワーク上にあるかどうかを判定するまず 1 について。iPhone にプリインストールされている「ショートカット」を用いれば、自身が接続しているネットワークの情報を取得することが可能である。同一アプリ内にある「オートメーション」にはわざわざ「Wi-Fi が特定のネットワークに接続されたとき」というトリガーも用意されているが、わざわざタップして応答しなければならないのが玉に瑕である。特に何の操作もせず打刻をしてほしいので、今回は 2 の路線で考えることにした。iPhone が同一ネットワーク上にあるかどうかを判定するこれについても 2 通りの方法が考えられる。 2-1. iPhone の private IP を固定しておき、自宅サーバから ping を打つなどして通るかどうかによって存在を確認する 2-2. 自宅ネットワーク内でパケットキャプチャを行い、iPhone からのトラフィックが存在するかどうか確認するまず 2-1 について。これには「iPhone がスリープ状態になっているときも ping は通らなくなるので、外出時との区別がつかない」という問題がある。上記については こちら で議論があり、以下の方法が提案されている。が、自分の環境で試してみたところ、どれもスリープ状態の iPhone を検知したりしなかったりで安定性に欠ける印象だった。 sudo arp-scan -I eth0 -l: iPhone の private IP (192.168.11.18) が表示されるか調べる tcping 192.168.11.18 62078: sudo nmap -Pn 192.168.11.18 をすると iPhone の空いているポートを調べられるので、そのポートに対して tcping をしてみる 単に sudo nmap -sT -Pn 192.168.11.18 を打つ: スリープ状態でも正しく存在を検知できる場合 (ただし数十秒かかる) があるが、逆に iPhone がネットワーク上にないときでもそれっぽい応答を返すこともあった (謎)また、この記事 に登場する snmpwalk も試してみた。これについては別記事を書いたが、結果的に得られるものは arp-scan の出力と大差なく、スリープ中の iPhone を正しく検知することはできなかった。自宅ネットワーク内で iPhone からのパケットをキャプチャする上記の議論を踏まえ、今回は 2-2 の方針を採用することにした。以前の記事で作成した図を再掲するが、我が家のネットワーク構成は以下のようになっており、iPhone → アクセスポイント → ポートミラーリング機能付きスイッチ → Raspberry Pi という流れでパケットキャプチャができるのである。Raspberri Pi 上で以下のコマンドを実行してみると、スリープ中の iPhone であっても 30 秒に一回は arp が流れていることが分かった。sudo tcpdump -n -v arp and src host 192.168.11.18今回は、このキャプチャ結果を 2 分おきにファイルに保存し、新規のファイルが存在するか (直近 2 分間で iPhone からの ARP が流れているか = iPhone がネットワーク上に存在するかどうか) を 5 分おきにチェックするようにした。これにより、最大 5 分の誤差で出勤と帰宅を検知することができる。実装以下、今回 Wi-Fi 打刻システムを実現するうえで最終的に行ったことをまとめていく。まず、下記コマンドで tcpdump から pcap ファイルを出力するようにする。sudo tcpdump -n -v arp and src host 192.168.11.18 -G 120 -w %Y%m%d_%H%M%S.pcap -Z ternbusty続いて、ファイルの存在を判定する簡単な Python スクリプトを書いた。ついでに、帰宅 or 出勤を検知したときは Slack にその旨を通知するようにもしてみた。from time import sleepfrom glob import globimport osfrom datetime import datetimeclass CellPhoneDetector(): def __init__(self) -&amp;gt; None: self.status: str = None def send_to_slack(self, message): WEBHOOK_URL: str = &quot;https://hooks.slack.com/services/xxxxxxxxxxxxxxxxxxxxxxxxxx&quot; requests.post(WEBHOOK_URL, data=json.dumps({ &#39;text&#39;: message, })) def run(self) -&amp;gt; None: file_exist: bool = False files: list[str] = glob(&#39;./*.pcap&#39;) dt_str: str = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) for file in files: filesize: int = os.path.getsize(file) if filesize != 0: file_exist = True os.remove(file) if file_exist: if self.status != &#39;in&#39;: self.send_to_slack(f&#39;:arrow_right: in: {dt_str}&#39;) self.status = &#39;in&#39; else: if self.status != &#39;out&#39;: self.send_to_slack(f&#39;:arrow_left: out: {dt_str}&#39;) self.status = &#39;out&#39; print(dt_str, &#39;:&#39;, self.status)if __name__ == &#39;__main__&#39;: cpd = CellPhoneDetector() while(1): cpd.run() sleep(300)これにより、出勤 or 退勤を自動で検知して以下のように slack にメッセージが送信されるようになる。あとはこれを月末にみて手動で打刻すれば、ヨシ！運用してみての感想今回はパケットキャプチャを行うことにより無事 Wi-Fi 打刻システムを実現することができた。先行事例 (ここ にまとまっている) では snmpwalk あるいは arp-scan を用いて接続している MAC address を取得しているものが多かったが、いずれもスリープ状態の iPhone を検知することはできなかった。最初に出社した時刻と最後に Wi-Fi につながっていた時刻を取得できればいいのであれば上記でも事足りるのかもしれないが、問題は現職の都合上ブツ切れのめちゃくちゃな勤務時間になりがちということである。実際、ある日の夜間オンコール (00:00-03:30, 06:00-07:00 に勤務) の際などは以下のような出力になった。このような労働時間を正確に把握するうえでは iPhone が単にスリープになっている状態と、外出している状態を判別することは critical になりうる。その意味でも、パケットキャプチャを利用したシステムをわざわざ構築した甲斐はあったと考える。今後の展望今回書いた Python スクリプトによって、自分が家にいるかどうかを数分の誤差で判定できるようになった。例えば FastAPI などを用いて上記コード中の cpd.status を返すような API を構築すれば、今後何らか「自分が家にいるとき or いないときのみ実行したい」ようなスクリプトを思いついたとき実現が容易になると考えられる。" }, { "title": "IoT を使って毎朝体重を測らざるを得ないようにする", "url": "/posts/measure-weight.html", "categories": "Technology, IoT", "tags": "Python, Raspberry Pi, Product", "date": "2022-10-01 00:00:00 +0900", "snippet": "概要外食続きであった出張から帰京し、一カ月ぶりに恐る恐る乗った体重計にはびっくりするような値が表示されていた。体重計を乗り降りして何度か測り直してみたものの値は変わらず……というわけで、出張前の体重に戻すまでは嫌々ながらも毎朝体重計に乗って現実と向き合うこととした。いわゆるレコーディングダイエットというやつである。普通に考えてこんな精神的負荷を伴う行為を習慣づけられるはずがないので、今回も 前回 と同様「体重計に乗らないとめちゃくちゃ嫌なことが起こる」方式での動機付けを行うこととした。具体的には「体重計に乗らない限り、心停止のときに作動するアラーム音が延々と鳴り続ける」システムを構築していこうと思う。方針まず「心停止のときに作動するアラーム音」というものがどんなものがご存じない方もいらっしゃると思うので聞いていただくとしよう。下記動画の 10 分ごろから流れているものである。実際の臨床現場では救急外来やスタッフステーションなどでこのアラームを聞く機会が多い。心停止が起こるとダッシュで駆けつけて心マなどをしなければならないため、いかに眠い当直中であってもこれが耳に入ると一瞬で目が覚め、いてもたってもいられなくなるのが職業病というものである。今回はこれをフル活用して、一刻も早く体重を測らねばという気持ちになるようにしたい。実装の概略を以下に示す。体重の計測はこちらの Withings Body を使って行う。いわゆるスマート体重計というやつなので、計測した体重が自動的に Withings のサーバに送信されるようになっており、さらに API 経由で計測データにアクセスすることもできる。実装としては、Raspberry Pi 上でスマート体重計 (Withings) の API を 3 秒おきに叩き、その日の体重データが取得できるようになるまで心停止アラーム (mp3 ファイル) を再生し続ける、という方針で進めていく。実装Withings API を用いたデータの取得まずは、Withings のサーバへアップロードされたデータに Raspberry Pi からアクセスしてみよう。Withings API は一般的な OAuth2 アプリケーションと同様、以下のように利用できる。まずは ここ にアクセスして developer 登録を行い、Client ID と secret を取得したのち以下の URL にアクセスする。https://account.withings.com/oauth2_user/authorize2?response_type=code&amp;amp;client_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;amp;scope=user.metrics&amp;amp;redirect_uri=http://localhost:8000/&amp;amp;state=devブラウザで認証を行い、リダイレクトされた URL の中から code を抽出。以下に code を埋め込んで実行する。curl --data &quot;action=requesttoken&amp;amp;grant_type=authorization_code&amp;amp;client_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;amp;client_secret=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;amp;code=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;amp;redirect_uri=http://localhost:8000/&quot; &#39;https://wbsapi.withings.net/v2/oauth2&#39;これの応答から得られた access_token を Bearer として渡すと、体重データを取得できるようになる。curl --header &quot;Authorization: Bearer xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; --data &quot;action=getmeas&quot; &#39;https://wbsapi.withings.net/measure&#39;access_token は 3 時間で失効するので注意。そのため、これ を叩いて access_token と refresh_token を更新する必要がある。Raspberry Pi から心電図アラームを再生するRaspberry Pi からオーディオを再生する方法はいろいろあるが、今回は python-vlc を用いる。sudo pip3 install python-vlcRaspberry Pi 自体にはスピーカーがついていないので、何かしら外付けのものを用意する必要がある。今回は音が鳴りさえすればええやろと思いとりあえずダイソーへ行ってみたところ、小型の Bluetooth スピーカーが 700 円という高いんだか安いんだか分からん値段で売っていたのでこれを使うことにした。CUI から Bluetooth 接続する方法については こちら を参照 (ちなみにダイソーで買ったスピーカーは LBS と表示されていた)。これを用いると、以下のような Python スクリプトでオーディオが再生できるようになる。from time import sleepimport vlcif __name__ == &#39;__main__&#39;: p = vlc.MediaPlayer() p.set_mrl(&#39;/home/ternbusty/withings/output.mp3&#39;) p.play() sleep(3) p.stop()Cron による定時実行以上をまとめると、上記の条件を満たす Python スクリプトは以下のようになる。import requestsimport jsonimport datetimefrom time import sleepimport vlcclass WeightGetter(): def __init__(self) -&amp;gt; None: today: datetime.date = datetime.date.today() self.today_ts = int(datetime.datetime(today.year, today.month, today.day, 0, 0).timestamp()) self.config_file_path = &#39;/home/ternbusty/withings/config.json&#39; with open(self.config_file_path, &#39;r&#39;) as f: self.config = json.load(f) def refresh_tokens(self) -&amp;gt; None: data: dict = { &#39;action&#39;: &#39;requesttoken&#39;, &#39;grant_type&#39;: &#39;refresh_token&#39;, &#39;client_id&#39;: self.config[&#39;client_id&#39;], &#39;client_secret&#39;: self.config[&#39;consumer_secret&#39;], &#39;refresh_token&#39;: self.config[&#39;refresh_token&#39;], } response: requests.Response = requests.post(&#39;https://wbsapi.withings.net/v2/oauth2&#39;, data=data) res_dict: dict = json.loads(response.text) self.config[&#39;access_token&#39;] = res_dict[&#39;body&#39;][&#39;access_token&#39;] self.config[&#39;refresh_token&#39;] = res_dict[&#39;body&#39;][&#39;refresh_token&#39;] with open(self.config_file_path, &#39;w&#39;) as f: json.dump(self.config, f) def get_weight(self): headers: dict = {&#39;Authorization&#39;: f&#39;Bearer {self.config[&quot;access_token&quot;]}&#39;} data: dict = { &#39;action&#39;: &#39;getmeas&#39;, &#39;meastype&#39;: 1, &#39;startdate&#39;: self.today_ts} response: requests.Response = requests.post(&#39;https://wbsapi.withings.net/measure&#39;, headers=headers, data=data) res_dict: dict = json.loads(response.text) if res_dict[&#39;status&#39;] == 401: self.refresh_tokens() return self.get_weight() return res_dictif __name__ == &#39;__main__&#39;: p = vlc.MediaPlayer() p.set_mrl(&#39;/home/ternbusty/withings/output.mp3&#39;) p.play() wg = WeightGetter() measure_today: dict = [] while len(measure_today) == 0: res_dict = wg.get_weight() measure_today = res_dict[&#39;body&#39;][&#39;measuregrps&#39;] print(datetime.datetime.now()) sleep(3) else: p.stop() print(&#39;measured!&#39;)これを crontab に登録して毎朝実行してみようとしたものの、なぜか音が鳴らない現象が発生したので これ のベストアンサーを用いて解決した。 以下の通り XDG_RUNTIME_DIR を指定したうえで、crontab を登録したところ定時実行に成功した。XDG_RUNTIME_DIR=/run/user/1000PATH=/home/pi/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin5 6 * * * /usr/bin/python $HOME/withings/withings.py課題と感想実際にこの心電図アラーム大音量攻撃に遭ってみると、自分で考えたとはいえ普通にやめてくれ～という気持ちになった。さらに、単に毎朝体重を測るようになるだけでなく、少しでも小さい値を出そうととりあえず着ている服を全部脱ぐので、そのままスムーズに入浴できるようになることも分かった。結果的に、10 日間で 2kg の減量にも成功した (やったね！)課題としては、体重を測定してからアラームが止まるので 30 秒程度かかることである (Withings API の仕様によるものなのでこちらにはどうしようもない)。これを本当になんとかしようとするなら、体重取得の判定を Withings API に依存するのではなく、体重計の下に圧センサでも敷いておいて、体重計に乗ったかどうかを判定するようにするのがよいのかもしれない。" }, { "title": "Raspberry Pi を SNMP マネージャとして利用する", "url": "/posts/snmpwalk.html", "categories": "Technology, Network", "tags": "Python, Raspberry Pi, Environment Setup", "date": "2022-09-01 00:00:00 +0900", "snippet": "動機別記事 で Wi-Fi 打刻について調べていたとき、この事例 を通して snmpwalk を用いた接続機器の情報取得に興味を持ったため。環境構築今回、自宅ネットワーク上にある Raspberry Pi を SNMP マネージャとして稼働させ、MIB を受信する方針とする。download-mibs もしておく。sudo apt-get install snmpdsudo apt-get install snmpsudo apt install snmp-mibs-downloadersudo download-mibsufw を用いて、SNMP に用いられるポート 161, 162 を開けておく。SSH で作業をしているので、22 番ポートも開ける。sudo ufw default denysudo ufw allow 22sudo ufw allow 161sudo ufw allow 162sudo ufw enableまた、デフォルトの設定に記載されている public では .1.3.6.1.2.1.1 と .1.3.6.1.2.1.25.1.1 以下しか閲覧できないようになっている (こちら を参照) ため、全てのサブツリーを閲覧できるように private という community を用意しておく。具体的には、/etc/snmp/snmpd.conf を編集し、以下の一行を追加する。rocommunity private 127.0.0.1 .1 上記の設定後、snmpd を再起動。sudo service snmpd restart接続されている機器の private IP や Mac Address を取得するMIB の OID は階層構造になっている (こちら を参照)。ここでは、試しに Table ipNetToPhysicalTable を取得してみることにする。snmpwalk -v 2c -c private 127.0.0.1 .1.3.6.1.2.1.4.35.1これにより、以下のような出力を得ることができる。IP-MIB::ipNetToPhysicalPhysAddress.2.ipv4.&quot;192.168.11.1&quot; = STRING: xx:xx:xx:xx:xx:xxIP-MIB::ipNetToPhysicalPhysAddress.2.ipv4.&quot;192.168.11.8&quot; = STRING: xx:xx:xx:xx:xx:xxIP-MIB::ipNetToPhysicalPhysAddress.3.ipv4.&quot;192.168.11.12&quot; = STRING: xx:xx:xx:xx:xx:xx...(中略)...IP-MIB::ipNetToPhysicalState.2.ipv4.&quot;192.168.11.1&quot; = INTEGER: reachable(1)IP-MIB::ipNetToPhysicalState.2.ipv4.&quot;192.168.11.8&quot; = INTEGER: stale(2)IP-MIB::ipNetToPhysicalState.2.ipv4.&quot;192.168.11.12&quot; = INTEGER: delay(3)" }, { "title": "名字の五十音分布を可視化してみる", "url": "/posts/aiueo-cartogram.html", "categories": "Technology, Others", "tags": "R, Visualization", "date": "2022-08-01 00:00:00 +0900", "snippet": "概要「五十音順の名簿であ行の名字多すぎない？」という疑問は一般的なもののようであり、実際 Twitter で「あ行 名字 多い」で調べると同様の感想が大量にヒットする。Mar 27, 2020この大学では人数を均等にするためにあ行を「あ・い」「う・え・お」に分割しているようである。確かに私も「い」から始まる姓の持主ではあるのだが、出席番号順では 40 人クラスで 8 番目なこともあったし、これは明らかに苗字の五十音表における分布の偏りを示唆しているように思える。この問題については先人があらかた調べをつけているようであり、例えば以下の記事などがある。 ア行は本当に多いのか？ - ?D of K 上記記事によるとあ行は 18.1% で最多なようであるが、せっかくなので分布を可視化してみようと思う。今回は個人的に好きな「カルトグラム (cartogram)」という手法を用いることする。Sep 3, 2021エリアカルトグラムとは、既存の地図を歪め、その地域の人口などを土地面積で置き換えたものである。今回は、名字の最初の文字別人口を計算し、それに基づいて五十音表を歪めてみようと思う。手法データ収集上記を実現するためには、まず日本の名字別人口のデータが必要になる。先述の記事で用いられたデータソースはすでにリンク切れしていたため、今回は 名字由来 net の名字ランキング (40000 位まで) を使用することにした。本ランキングは漢字表記の名字毎に集計されているので、例えば「東」に「ひがし」と「あずま」がひとくくりになってしまっているが、そこはまあしゃーなしとしてもっとも代表的と思われる読み 1 つを採用する方針とした。以上のようにして、日本の名字およびその読み、人口をまとめた csv を作成した。以上を、代表的な読みの最初の文字別に分類したものがこちらである。濁点を含むものについてはそれを取り除いたひらがなで集計を行った。一部を以下に示す。冒頭の話であ行の新入生が「あ・い」と「う～お」に分けられているという話があったが、「あ・い」で 1433 万人、た行全体で 1400 万人なのでまあ妥当なのではと思えてくる。五十音表を地球上に設置する上記の csv で数字だけ見ていてもイマイチピンとこないので、先述の通りカルトグラムを描いてみることにする。調べてみたところ R にあるライブラリ cartogram を利用できそうな感じであったが、そもそもは地図に対して適用するものであるため、まずは五十音表を地図データ (geojson など) の形式で作成する必要がある。五十音のマス目を地球上のどこに設置してもいいのだけど、今回は適当に緯度経度を設定して京都に置いてみることにした。上図は Python で上手いこと geojson ファイルを作成し、geojson.io で実際の地図上に重ねてみたもの。「を」「ん」から始まる名字は一つもなかったので今回は割愛させていただいた。カルトグラムを描いてみるまずは作成した地図データを表示してみるところから。上記のデータは緯度経度で座標を指定しており、これを投影変換する必要がある。今回は、京都府を含む平面直角座標 (EPSG 6674) で transform してみることにする。library(cartogram)library(tidyverse)library(geojsonio)library(ggplot2)library(sf)spdf &amp;lt;- geojson_read(&quot;aiueo_table.json&quot;, what = &quot;sp&quot;)stat &amp;lt;- read.table(&quot;stat.csv&quot;, sep = &quot;,&quot;, header = TRUE)spdf@data &amp;lt;- spdf@data %&amp;gt;% left_join(., stat, by = c(&quot;name&quot; = &quot;first_letter&quot;))sfno &amp;lt;- st_as_sf(spdf)sfproj &amp;lt;- st_transform(sfno, crs = 6674)windowsFonts(MEI = windowsFont(&quot;IPAexGothic&quot;))ggplot() + geom_sf(data = sfproj) + geom_sf_label(data = sfproj, aes(label = name), size = 8, family = &quot;MEI&quot;, label.size = 0, fontface = &quot;bold&quot;, alpha = 0.5, label.r = unit(0.4, &quot;lines&quot;), label.padding = unit(0.4, &quot;lines&quot;)) + theme(text = element_text(size = 24), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())こんな感じで五十音表を ggplot で描いてみた。今度はこれを歪めてみよう。cartogram &amp;lt;- cartogram_cont(sfproj, &quot;count&quot;, itermax = 50)ggplot() + geom_sf(data = cartogram, aes(fill = count)) + geom_sf_label(data = cartogram, aes(label = name), size = 8, family = &quot;MEI&quot;, label.size = 0, fontface = &quot;bold&quot;, alpha = 0.5, label.r = unit(0.4, &quot;lines&quot;), label.padding = unit(0.4, &quot;lines&quot;)) + theme(text = element_text(size = 24), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())名字由来 net のデータをもとに作成感想 眺めてみてまず思うのが、「ら」行あまりにも細すぎないかということである。実際に数字を確認してみると、最も人数が少なかった「れ」から始まる名字の人はこの統計上 2100 人 (全体の 0.001%) しかいないらしい。 横に眺めてみると、「あ」段は全体に数が多いことがわかる。逆に「え」段はどの行においても圧倒的に少ない (そもそも名字に限らず日本語の単語全体に同様の傾向があったりするんだろうか？ 日本語のエンドユーザであって成り立ちは知らないので、詳しい方は教えてください)。さいごに今回のデータ (名字の最初の文字別人口、五十音表の geojson データ) は こちらのレポジトリ で参照できる。五十音表を歪めてみたくなった方はご利用ください。" }, { "title": "特定の YouTube チャンネル内の動画をキーワード検索できるサービスを作った", "url": "/posts/omoch.html", "categories": "Technology, Web", "tags": "Python, Wordpress, Product", "date": "2022-07-01 00:00:00 +0900", "snippet": "最近になって定期更新される YouTube チャンネルを観る習慣がついた。特定の発言がどの動画で出てきたかを探すために、キーワード検索を行うサービスを作成した。使用したコードは こちら、完成したものは こちら。概要 データの取得は YouTube API v3 を用いて行った。一つの動画について、データをまとめたファイルとサムネイル画像をローカルへ保存するようにした。 サイト自体は Wordpress で立ち上げ、検索機能も Wordpress に標準搭載されているものを用いた。WP-CLI を使うことにより、上記データが自動的に記事として登録されるようにした。 以下、実装の手順を細かく見ていく。データの取得事前準備 Google Cloud Platform 経由で API KEY を取得しておく。 データを取得するため、チャンネルの動画をまとめたプレイリストの ID を把握する。チャンネルのトップページから「すべて再生」をクリックすると、チャンネルの動画が最新のものから順に並んだプレイリストにアクセスできるので、URL の list?= 以下を控えておく。データの保存データ取得方法の概要を示す。詳細な仕様については こちらのスクリプト を参照。 YouTube API v3 を叩くことによって、以下のようにプレイリスト内にある動画のメタデータを取得。さらに、それぞれの動画についてデータをまとめたファイルを comments/[VideoID].md へ保存する。def process(self, next_page_token=None) -&amp;gt; None: &quot;&quot;&quot; Get videos from a playlist specified by `self.playlist_id`. If next_page_token exist, call this function recursively &quot;&quot;&quot; sleep(1) params: dict[str, str] = { &#39;playlistId&#39;: self.playlist_id, &#39;key&#39;: self.API_KEY, &#39;part&#39;: &#39;snippet&#39;, &#39;maxResults&#39;: 50, } if next_page_token is not None: params[&#39;pageToken&#39;]: str = next_page_token response: requests.Response = requests.get(self.endpoint + &#39;playlistItems&#39;, params=params) resource: dict = response.json() items: dict = resource[&#39;items&#39;] for item in items: self.idx += 1 # Update `self.video_info` self.process_video_info(item) サムネイル画像を thumbnails/[VideoID].jpg へ保存する。def download_thumbnail(self) -&amp;gt; None: &quot;&quot;&quot; Downlowd thumbnail of the video in the `self.video_info` &quot;&quot;&quot; response: requests.Response = requests.get(self.video_info.thumbnail_url) image = response.content with open(f&#39;./thumbnails/{self.video_info.video_id}.jpg&#39;, &quot;wb&quot;) as f: f.write(image) 取得が完了した動画のメタデータについては log.tsv に保存しておく。 以下のコマンドを cron に登録し、上記 Python スクリプトを毎日実行するようにした。取得する動画は、公開から一週間経っており、かつ前回までの実行で取得していない (log.tsv に含まれていない) ものに限定する仕様とした。/usr/local/bin/python /home/ternbusty/download_video_info.pyWordpress への登録上記 Python スクリプト内で、動画データを取得したついでに Wordpress へ登録するスクリプトも実行するようにする。def register_to_wp(self) -&amp;gt; None: &quot;&quot;&quot; Register a comment file to wordpress &quot;&quot;&quot; dt_str = self.video_info.published_at.split(&#39;T&#39;)[0] subprocess.run([&#39;bash&#39;, &#39;register.sh&#39;, self.video_info.video_id, self.video_info.title, dt_str])register.sh の中身は以下の通り。 wp post create を用いて Wordpress への記事登録を行う。後述する理由により post_excerpt には動画の ID を設定した。 wp media import によってサムネイルをインポート &amp;amp; featured image への設定を行った。ID=$1POST_TITLE=$2DT=$3PATH=&quot;./comments/${ID}.md&quot;echo $PATHPOST_ID=`/usr/local/bin/wp post create ${PATH} --path=&quot;./www/&quot; --post_title=${ID} --post_date=${DT} --post_status=publish --post_excerpt=${ID} --porcelain`echo $POST_ID/usr/local/bin/wp post update ${POST_ID} --path=&quot;./www/&quot; --post_title=&quot;${POST_TITLE}&quot;/usr/local/bin/wp media import ./thumbnails/${ID}.jpg --path=&#39;./www/&#39; --post_id=${POST_ID} --featured_imageWordpress の設定テーマには Cocoon を用いた。また、/wp-content/themes/cocoon-child-master/functions.php に以下を追記した。 specific_url_redirect(): 検索結果をクリックすると動画ではなくデータをまとめた記事自体にアクセスされてしまうので、リダイレクトを行う。ここで先ほど登録した excerpt を用いて動画 ID を取得し、URL を生成した (本当は記事の ID を用いたかったが、動画 ID のなかには記事の ID に用いることができない文字が含まれている場合があったため)。 change_posts_per_page(): Wordpress の検索機能では、例えば “あいう　えお” などと全角スペースを用いて検索を行うと、”あいう” AND “えお” ではなく “あいう　えお” という文字列自体が検索されてしまうらしい。そのため、検索クエリ内の全角スペースを半角に置換するようにした。 custom_posts_search_orderby(): 検索結果が古い順に表示されるようにした。add_action(&#39;get_header&#39;, &#39;specific_url_redirect&#39;);function specific_url_redirect(){ $url = $_SERVER[&#39;REQUEST_URI&#39;]; if (strstr($url, &#39;posts&#39;)){ $id = get_the_ID(); $excerpt = get_the_excerpt($id); $new_url = &#39;https://www.youtube.com/watch?v=&#39;.$excerpt; wp_redirect($new_url, 301); exit; }}add_action(&#39;pre_get_posts&#39;, &#39;change_posts_per_page&#39;);function change_posts_per_page($query) { if (is_admin() || !$query-&amp;gt;is_main_query()){ return; } if ($query-&amp;gt;is_search()) { $query-&amp;gt;set(&#39;post_type&#39;, &#39;post&#39;); $s = $query-&amp;gt;get(&#39;s&#39;); $s = str_replace(&#39;　&#39;, &#39; &#39;, $s); $query-&amp;gt;set(&#39;s&#39;, $s); }}add_filter(&#39;posts_search_orderby&#39;, custom_posts_search_orderby);function custom_posts_search_orderby() { return &#39;post_date asc&#39;;}サイトの見た目を整えるWordpress のカスタマイズ機能を用いてサイトに こちらの CSS を設定した。何も分からんので !important だらけでやばくなってしまったけど、まあええか……感想今まで web サイトの立ち上げには Jekyll しか使ったことがなく、Wordpress は初めてだったので何も分からんわという感じで悪戦苦闘していた。投稿をクリックで動画に飛ぶところ、リダイレクトではなく単にその投稿へのリンクを張ったほうがよい気がするのでそのうち functions.php をごにょごにょして何とかしたい。" }, { "title": "自宅ネットワークを Grafana でモニタリング (3)", "url": "/posts/raspy-grafana-3.html", "categories": "Technology, Network", "tags": "Network, IoT, Product, Python, Grafana, raspy-grafana", "date": "2022-06-15 00:00:00 +0900", "snippet": "前稿までで実装は大体終わったので、解析結果でいろいろ遊んでみることにする。もともとはTwitter、YouTube、Amazon Prime Video のトラフィックを監視したいという動機であったので、まずはそれが達成できているか検証してみよう。監視対象サービスのトラフィックを眺めるTwitter寝る前 (AM 1 時) に寝床で TL を眺め、AM 6 時に起床した瞬間に TL を開き、その後短時間二度寝してまただらだら TL を眺めていたのが手に取るようにわかる。ちなみに就寝中にも継続してアクセスがあるのは、PC で twitter.com を開いたままスリープするのを忘れて寝たからである。どうやら継続的にリクエストを送って内容を更新していることが分かる。7:00 すぎからは twitter.com を閉じて tweetdeck.com を開いてみた。単に TL を開いているときより密なアクセスが確認できた。YouTubeYouTube 再生中に流れてくるパケットを眺めていると、どうやら rr3---sn-oguesn6d.googlevideo.com のような名前のドメインからのトラフィックが増えるようである。今回はドメイン名に googlevideo を含むものに nickname YouTube を設定することとした。上記は 20:45-21:30 ごろまで (一度休憩を挟みながら) わりとうるさい動画を流しており、その後 23:00-23:30 ごろまでほとんど動きのない動画を眺めていたときの記録である。再生していた時間がはっきりわかって楽しい。Amazon Prime Video日付が変わったころから適当なアニメを流していたらこんな感じになった。上記同様、ドメイン名に aiv-cdn.net を含むものに nickname Amazon Prime Video を設定している。常駐サービスのトラフィックを眺めるせっかくすべてのパケットをキャプチャしているのだから、上記以外の web サービスやソフトウェアがどのような通信をしているかを眺めてみることにする。LINEPC で LINE を起動したままトラフィックを見てみることにした。小さな山があるのはメッセージの受信があったタイミングや iPhone からも LINE アプリを開いたタイミングに該当する。7:22 に適当な写真を iPhone の LINE から送信してみたところ跳ね上がりが確認できたので、ちゃんと拾えていそうだ。Dropbox特に何もファイル操作が生じていない状態であっても不定期なアクセスが確認できる。ファイルの保存が発生するとはやり跳ね上がりが確認できる。こちらもしっかり拾えていそうだ。SlackPC で Slack のアプリ本体は起動せず、常駐させておいたときの記録が下図である。記録期間中にメッセージは一通も来なかったが、それでも 10 秒に 10-50 回程度のトラフィックが大体常に存在することが分かる。ちなみに Slack の常駐を解除しない状態でパケットキャプチャを開始したため Slack の IP アドレスに対応する DNS レスポンスを拾うことができず、当初は AWS への謎のトラフィックが大量に存在することが分かるだけで正体不明であり結構悩んだ。ものは試しということでバックグラウンドで実行されていた Slack を落としてみたところ、綺麗にトラフィックが 0 になったので感動した。しばらくして Slack を再起動してみたところ、その過程に DNS リクエストが含まれていたようで以降はちゃんと Slack として認識できるようになった。やったね！課題データベースの容量がでかい これを執筆している現在スクリプトを動かしてちょうど 3 日になるが、tcpdump_records はすでに 27 万行、17MB に達している。 1GB くらいなら許容できるとはいえ、このまま肥大し続けるとクエリにも時間がかかる一方になってしまう。例えば 1 週間くらい経ったデータを削除するようなスクリプトが必要になりそうだ。web サービスを特定できない IP アドレスは結構存在する 何らか AWS でホスティングされているサーバからのトラフィックであることは分かっても、上記 Slack のように DNS レスポンスを拾えずそもそも何のサービスから送られているものかの特定が困難なことがしばしばある。 これ を見る限り ntopng というソフトウェアは今回やったようなアプリケーション分析を製品として実現しているようだが、内部でどのような操作をしているかについては興味がある。対応している web アプリケーションの種類は 250 種類程度と限定されているようなので、単にそれらの web サービスすべてについて net range を記録しておくことにより何とかしているのかもしれない。それはそれでちょっと大変そうだ。感想 ネットワークもデータベースも入門書を読む段階から始めたのでかなり時間がかかった。結果的にある程度満足のいくものが作れて、うれしい……！ 今回の監視システムは自己の怠惰な生活の反省につながるだろうが、さらに自分を律しようとする場合、例えば「nickname が Twitter である IP アドレスからのトラフィック総量を計算しておき、一日の規定量を超えた場合はブロック」なども考えられる。以前の記事でファイアウォールを用いた接続のブロックを試みたことがあるが、ネットワーク上のすべての機器についてブロックを行うならルータかスイッチ上でフィルタリングすることになりそうだ。それらの機器上で特定 net range の IP をまとめてブロックする操作を上手いことコマンドラインで行うことができれば可能にはなりそうだが、これは今後の課題としたい。" }, { "title": "自宅ネットワークを Grafana でモニタリング (2)", "url": "/posts/raspy-grafana-2.html", "categories": "Technology, Network", "tags": "Network, IoT, Product, Python, Grafana, raspy-grafana", "date": "2022-06-14 00:00:00 +0900", "snippet": "概要 前回のネットワーク構築を経て、自宅ネットワークすべての機器におけるトラフィックがRaspberry Pi へ流入するように設定することができた。本記事では Raspberry Pi にてパケットキャプチャを行い、Grafana での可視化を行う。最終的に、どの時間帯にどのウェブサービスへ接続していたかを知るのが目標である。 全体の構成は以下の通り。 tcpdump を用いて pcap ファイルを書き出し、それを Python を用いて解析する。同じ Raspberry Pi 上に立てておいた MariaDB に解析後のアクセスログを蓄積し、Grafana からはそのデータベースを読み込んで可視化する形式を採る。以下、具体的な実装方法を見ていこう。tcpdump でパケットキャプチャ tcpdump の Raspberry Pi へのインストール自体は sudo apt install tcpdump で簡単にできる。 tcpdump には -w というオプションがあり、生データをそのままファイルに書き込むことができる。-G オプションと組み合わせれば、以下のように 10 秒おきにカレントディレクトリへ pcap ファイルを書き出すことができる。 ここでは、フィルタをかけて http, https および後述する理由で DNS をキャプチャするようにした。sudo tcpdump -v -n port 53 or port 80 or port 443 -G 10 -w %Y%m%d_%H%M%S.pcapパケット解析今回、パケット解析には Python 3.10.1 を用いることとした。作成する Python スクリプトは、以下の機能を備えなくてはならない。 カレントディレクトリにある pcap を読み込み、通信先の IP アドレスを抽出する IP アドレスから web サービス名を特定する pcap ファイル 1 つ (10 秒間) で、どの web サービスに対するアクセスが何回行われていたかを集計する 3 のデータを MariaDB に投げる以降は手順を一つずつ追ってみていこう。Python で pcap ファイルの読み込み 保存された pcap ファイルはバイナリであるため、そのまま Python で読み込むことはできない。 今回は dpkt というライブラリを用いて pcap ファイルの読み取りを行った。これを用いれば、参考記事 のようにパケット 1 つ 1 つの種類判定から IP アドレス抽出まで簡単に行うことができる。IP アドレスから web サービス名の特定 抽出したアドレスがどの web サービスに対応するかを判定する箇所。こんなん nslookup なり dig -x なり使って逆引きすれば簡単だろと思ったら意外な落とし穴があった。 例えば dig github.com で返ってくるのは 52.192.72.89 であるが、いざ dig -x 52.192.72.89 を打ってみると返ってくるのは ec2-52-192-72-89.ap-northeast-1.compute.amazonaws.com. である。IP アドレスを逆引きしたところで分かるのはそれがなんらか AWS でホスティングされているサービスであることくらいで、意図した宛先が github.com であったことは分からないのである。 これを解決するため、今回は以下の方法を採ることにした。 (DNS cache 等に残っていない限り、HTTP リクエストの前には DNS があるはずなので) まず先行する DNS レスポンスを読み、この後登場する IP アドレスとドメイン名の組み合わせをテーブルに記録しておく 上記のテーブルに基づいて、その後に現れる TCP なり UDP なりのパケットに含まれる IP アドレスをドメイン名に変換する 上記の方針は完璧に見えるが、実際は ipconfig /flushdns などしておいた状態であっても、先行する DNS なしで初見の IP アドレスを含むパケットが飛び込んでくるケースがある。その場合はとりあえず dig -x を用いてドメイン名を仮決定しておき、以降何らかのタイミングでその IP アドレスを含む DNS レスポンスが登場することがあればレコードを上書きしドメイン名を正式に決定する方針とした。 これを pcap ファイルに含まれるすべてのパケットについて行えば、pcap ファイル 1 つ (10 秒間) のなかでどの web サービスに対するアクセスが何回行われていたかを集計することができる。Nickname の設定 上記のようにすれば IP アドレスに対応するドメイン名を取得できるが、例えば t8.dropbox.com と bolt.dropbox.com を区別して可視化する意義があるかと言われればそうではない。むしろ、同じ web サービスとの通信は一つにまとめて Dropbox としてしまいたい。 まとめたいサービス (Dropbox, Google など) については、例えばドメインの文字列の中に dropbox が含まれていたら nickname Dropbox を、google が含まれていたら nickname Google を設定する、という作業をやっておくことにした。その他の初出のサービスについては、domain 名を . で split したうえで、generic TLD および country code TLD を除いた一番末尾の文字列を nickname として採用する……つもりだったのが、generic TLD 自体データベースの準備 上記を踏まえると、今回必要なテーブルは以下の 2 つとなる。 前節に登場した、DNS リクエストのレコードを蓄積するテーブル dns_records 集計された情報 (いつどの web サービスに対して何回アクセスが行われていたか) を蓄積するテーブル tcpdump_records 今回は、こちら を参考に Raspberry Pi へ MariaDB をインストールすることで上記 2 つを実現する方針とした。 適当なデータベース (ここでは network)を作成したうえで、1 のテーブルを以下のように作成した。is_definite は、パケットキャプチャ内の DNS レスポンスに基づいてテーブルに登録された場合は 1、そうでない場合 (dig -x で逆引きされた場合など) は 0 が登録される。CREATE TABLE dns_records ( id INT AUTO_INCREMENT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ip_addr TEXT, domain TEXT, is_definite BOOL, PRIMARY KEY(id))DEFAULT CHARSET=utf8; 続いて 2 のテーブルを以下のように作成した。pcap 取得時の時刻が timestamp として記録され、以下は domain, nickname, count (1 ファイル内で何回アクセスがあるか) の列を作成する。CREATE TABLE tcpdump_records ( id INT AUTO_INCREMENT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP, domain TEXT, nickname TEXT, count INT, PRIMARY KEY(id))DEFAULT CHARSET=utf8; データベースを Python から操作するにあたり、今回は mysqlclient というライブラリを用いることとした。Python 上からデータベースとの通信を確立し、簡単に SQL 文が実行できる。 実装は こちら のコードを参考にした。Grafana の準備 上記でデータベースの準備まで整ったので、あとは Grafana で可視化すればよいだけである。インストールは こちら を参考にした。 インストールできたら localhost:3000 (別に Rapberry Pi の private IP を指定して http://192.168.11.9:3000/ などとすれば別端末のブラウザでも接続できる) にアクセス。新しいデータソースとして、localhost:3306 上に立ち上がっている MySQL サーバを登録する。 続いてグラフを作成し、Query 部分に以下を入力する。Grafana での可視化には nickname を用いたいので、nickname AS metric、GROUP BY nickname, ts とした。SELECT UNIX_TIMESTAMP(ts) AS time, nickname AS metric, sum(count) AS valueFROM tcpdump_recordsWHERE $__timeFilter(ts)GROUP BY nickname, tsORDER BY ts; 上記を入力して適当なところをクリックすると……やったね！今回書いたコードは こちら。以上でとりあえずの実装は終了、次稿では可視化結果をもとにいろいろ遊んでみることにする。" }, { "title": "自宅ネットワークを Grafana でモニタリング (1)", "url": "/posts/raspy-grafana-1.html", "categories": "Technology, Network", "tags": "Network, IoT, Product, Python, Grafana, raspy-grafana", "date": "2022-06-13 00:00:00 +0900", "snippet": "動機いわゆるコロナ禍が始まってはや 2 年、必然的に自宅にいる時間が長くなったものの、その時間を最大限勉強など活用できているかと言われると非常に怪しい。業務後には YouTube をだらだら自動再生しながら作業をし、何か一区切り発生するたびに気付けば Tweetdeck をぼーっと眺め、休日には Amazon Prime Video にあるアニメを一気見してしまう。こんな生産性のない毎日をどうにかするため、まずは「おうち時間」における現状の web サービス利用状況をセルフ監視することとした。ネットワークの監視をするとき真っ先に思いつくのはパケットキャプチャであるが、今回はメインで使っている PC 以外の通信も監視したい (寝っ転がって iPhone で Twitter を眺めているときのトラフィックも取得したい) ためいろいろと工夫を凝らす必要があった。最終的には大分前に見た以下ツイートのような形式を目指すとして、本稿ではまず自宅ネットワークの再構築を行う。Sep 22, 2021概要 今回目指すネットワークの構成は上図の通り。まず、パケットキャプチャ自体はその辺に転がっていた Raspberry Pi で行うこととした。ここにすべてのパケットが流入するようにする必要があるため、ルータと有線接続の間にミラーリングポート対応のスイッチを挟むこととした。 通常のようにルータから Wi-Fi を用いて各種モバイル端末に接続してしまうと、そのパケットはスイッチを通過しないのでキャプチャすることができない。そこで、今回は既存のルータに備わっている無線 LAN 機能を無効化したうえで、スイッチから接続した無線 LAN アクセスポイントを新設し、そこから iPhone 等に接続するようにした。各種機器の設定 スイッチの設定 (NETGEAR GS305E) Amazon タイムセールでポートミラーリングに対応したスイッチが売っていたのでそれを購入した。管理画面にアクセスできさえすればポートミラーリングは非常に簡単で、以下のようにミラー元 (複数選択可) とミラー先を選択できるようになっている。 ここでは、②アクセスポイント ⑤ 有線接続の PC のパケットを ③ Raspberry Pi へミラーする方針とした。 アクセスポイントの設定 Wi-Fi ルータをもう一つ購入しブリッジモードにするなりなんなりすることも可能であったが、別にルーティング機能が必要なわけではないしなあ……と思い今回は tp-link RE330 を購入した。本来の使い道は Wi-Fi の中継器でありおそらくほとんどの人がその用途で使っていると思われるが、実はルータから有線で接続し Wi-Fi のアクセスポイントとして利用することも可能である。設定は こちら を参考に行った。 携帯端末の接続設定 携帯端末などにおける Wi-Fi の接続先を、ルータから飛んでいる方ではなくアクセスポイントからの方へ切り替える必要がある。今回は、紛らわしい状態になるのを避けるためルータの無線設定を無効化することにした。 実験上記の接続を終えたあと、携帯や PC における通信がきちんと拾えているかどうかを確認するため、Raspberry Pi 上で tcpdump を用いてパケットをキャプチャしてみることとした。以下は、iPhone (192.168.11.18) から Twitter (net range 104.244.40.0 - 104.244.47.255) にアクセスしてみた際の出力冒頭である。pi@raspberrypi:~ $ sudo tcpdump src host 192.168.11.18tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes21:30:52.465080 IP 192.168.11.18.56217 &amp;gt; 104.244.42.194.https: Flags [S], seq ...iPhone と Twitter サーバ間の通信が拾えていそうだ。やったね！以上でハードウェアの環境構築は終了、次稿ではパケットしたキャプチャを可視化する方法について検討していく。" }, { "title": "コンピュータシステムの理論と実装 (11)", "url": "/posts/nand2tetris-11.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Compiler, Jack, Python, nand2tetris, Book Review", "date": "2022-01-19 00:00:00 +0900", "snippet": "前章で構文解析まで終了しているので、今回はシンボルテーブルの管理とコード生成の部分を完成させていく。11 章 コンパイラ#2: コード生成シンボルテーブルの実装 まずは変数の管理から。本文に記載されている通り、 サブルーチンスコープ argument: サブルーチンの入力を指定する仮引数 (パラメータ変数) local: サブルーチン内のみで有効なローカル変数。var で宣言 クラススコープ field: C++ や Python でいうクラスのメンバ変数 static: クラスの先頭で宣言される変数であり、そのクラスから生成される全てのオブジェクトで共有される に Python の dict の形で格納していく。参照するときは当然サブルーチンスコープを優先する。 次に関数の方を何とかしなくてはならない。Jack 言語には 3 種類の Subroutine があり、 function: クラスに附属し、インスタンスに依存しない。呼び出すときは className.subRoutineName() constructor: 慣例的に new という名前が用いられる。呼び出すときは function と同じ method: C++ や Python でいうメンバ関数。インスタンス依存。呼び出すときは、同一クラス内なら単に subRoutineName()、そうでなければ instanceName.subRoutineName() となる。 サブルーチンの種類が method である場合、call 時にインスタンスの参照を隠れ引数として push しなければならないため、call をコンパイルする際にはサブルーチンの種類判定が必要になる。ここで、コンパイラが関数の call に遭遇した際の挙動を考えてみる。subRontineName() の際は method で確定。hoge.subRoutineName() の際は、hoge が既に宣言されており上記の変数シンボルテーブルに登録されていればインスタンス (つまりこのサブルーチンは method)、そうでなければ hoge はクラス名でサブルーチンは constructor あるいは function であることが確定する。 呼び出し時にサブルーチンが method であるかどうかさえ判定できればよいので、サブルーチンのシンボルテーブルをわざわざ作成しなくてもとりあえずコンパイルは可能である。当該クラスにそのサブルーチンが本当に存在するかどうかの判定は行わないことになるため、ない関数を書いても一切のエラーを吐かない激ヤバコンパイラが出来上がることになるが……。コード生成ここからは、各処理の概要とそれぞれの躓きポイントをメモしていこうと思う。実際の作業は、公式で提供されているコンパイラで .jack から .vm の正解ファイルを生成し、自分のコンパイラから出力されたファイルと正解のファイルを比較することにより行った。 サブルーチン宣言のコンパイル サブルーチンの種類が何であれ、VM コード上では function 表記になるので注意。Main クラス内にある hoge というサブルーチンがあり、内部で n 個のローカル変数が定義される場合の宣言は function Main.hoge n となる。n の値自体は subRoutineBody をコンパイルしてみないと分からないため、とりあえず空欄にしておき処理後に追記する方針とした。 サブルーチンの種類が method のときは this がオブジェクトのベースアドレスを指すようにしなくてはならないため、push argument 0 pop pointer 0 を宣言後すぐに書く。 サブルーチンの種類が constructor である場合は field 変数のためにメモリ割り当て作業も行う必要があるため、push constant n call Memory.alloc 1 pop pointer 0 を宣言後すぐに書くことになる。 let のコンパイルlet a[1] = ... を処理するときは、次のようなコードを生成することになる。 push constant 1 // 添字push local 2 // a が 3 番目に宣言されたローカル変数の場合add // これで、スタックトップが a[1] のアドレスになる// (右オペランドを処理してスタックトップに持ってくる)pop temp 0 // 右オペランドの処理結果を temp 0 に退避するpop pointer 1 // that の指す先をスタックトップ、つまり a[1] にするpush temp 0 // 退避しておいた右オペランドの処理結果をスタックトップに戻すpop that 0 // 右オペランドの処理結果を that の指すアドレス、つまり a[1] の位置に格納 while のコンパイル while 文のコンパイル結果は以下のようになるので、これを目標にコード生成をすればよい。 label WHILE_EXP0// while () のカッコ内に入る expression を処理notif-goto WHILE_END0 // カッコ内が false の場合、ここが true になり末尾に跳ぶ// {} 内の statements を処理goto WHILE_EXP0label WHILE_END0 while 文の始まりと終わりに固有のラベルを振って制御することになるが、ここで他の while 文のラベルと被らないようにラベルの末尾にカウンタを振ることにする。ここで注意すべきは while 文が多重になっているときであり、この場合 statements 処理時に再帰で呼び出しまくっていると while 文のカウンタがめちゃくちゃになりうる。今回のコードでは、クラスのメンバ変数で管理しているカウンタとは別に関数内でカウンタの値を保持しておく方針とした。 if のコンパイル コンパイル結果は以下のようになる。while 同様、多重になっている場合の処理に注意が必要。 // (expression) の処理if-goto IF_TRUE0goto IF_FALSE0label IF_TRUE0// {true のときの statements}goto IF_END0label IF_FALSE0// {false のときの statements}label IF_END0 return のコンパイル return hoge; の場合は hoge を処理してスタックトップに載せてから単に return と書けばよい。 void の関数であり単に return; の場合でも、簡単のため push constant 0 return と疑似的に 0 を返すようにする。 do のコンパイル do subRontineName() の場合 上述の通りその関数は method であることは確定なので、push pointer 0 をすることにより this の指す先、つまりオブジェクトの参照を隠れ引数として push してから他の引数を push し、その後 call className.subRoutineName n する必要がある (n はパラメータの数)。 do hoge.subRoutineName() の場合 hoge がインスタンスの場合その関数は method であるため、まず push local 0 などでインスタンスを隠れ引数として push する。他の引数を push したのち、インスタンスの型名 (つまりそのインスタンスの生成元であるクラス名) を取得して call className.subRoutineName n とする。 それ以外の場合 hoge はクラス名であるため、単に call className.subRoutineName n とすればよい。 call の末尾につけるべき n はパラメータ処理の後でないと判明しないため、とりあえず空欄にしておいて後で埋める方針を採った。method の場合は +1 すべきなので注意。 上述の通り、void の関数を実行したとしてもスタックトップには 0 が残ってしまう。これを解決するため、いずれの場合でも末尾に pop temp 0 を追記して値を捨てる。 expression のコンパイル 例えば a - b のコンパイルの場合、push a push b sub とすればよい。 ややこしいのが、単なる -b のときは push b neg としなければならないこと。- 記号が登場した場合は、それが expression の先頭に位置する token でないかどうかをチェックする必要がある。 term のコンパイル let のコンパイル時にも問題になったが、a[1] のような term の処理は以下のようにする。 push constant 1 // 添字push local 2 // a が 3 番目に宣言されたローカル変数の場合add // これで、スタックトップが a[1] のアドレスになるpop pointer 1 // that が a[1] を指すようにするpush that 0 // that の指す先、つまり a[1] の中身をスタックトップに持ってくる 文字列処理 まず文字列の文字数 l を取得し、push constant l call String.new 1 とする。 アルファベットの指定は Unicode コードポイントを用いて行うことになり、これは Python では組み込み関数の ord() で実現できる。末尾に a を追加した場合、push constant 97 call String.appendChar 2 を呼べばよい。 感想 とりあえずできたはいいものの、一切のシンタックスエラーを検出しないばかりか、存在しない関数を書いてもなんの疑いもなくコンパイルが通るようになっておりとても実用に耐えるものではない。 完成したコンパイラは これ、シンボルテーブルは これ である。慣れない言語においてコンパイラ作成という目新しい作業をすることになったのでめちゃくちゃ疲れた。" }, { "title": "コンピュータシステムの理論と実装 (10)", "url": "/posts/nand2tetris-10.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Compiler, Jack, Python, nand2tetris, Book Review", "date": "2022-01-15 00:00:00 +0900", "snippet": "前章までで中間コードをアセンブリに変換する部分は完成したので、本章からは後半部分である Jack 言語から中間コードへのコンパイラを書いていく。10 章 コンパイラ#1: 構文解析tokenizer を書くコードを token ごとに区切り、xml として出力するコードを書けばよい。こんなん半角スペースで分割してそれぞれの要素が何であるかを判定していけばいいだけやんとか思っていたが、よく考えたらこれは誤り (&quot;Hello world&quot; は半角スペースを含むが一つの token であるし、a[0] は半角スペースを含まないが複数の token を含んでいる)。なので、行ごとに一文字ずつ走査していき、 &quot; が発見されたら終わりが見つかるまで idx を進め、見つかったら STRING_CONST として token に加える symbol や半角文字が見つかったらある token の終わりとみなし、まだ出力されていない文字列を token として出力という操作が必要になる。import reimport pathlibimport sysimport tokenDicclass TokenObject: def __init__(self, token, token_type) -&amp;gt; None: self.token: str = token self.token_type: str = token_type self.before: &#39;list[str]&#39; = [] self.after: &#39;list[str]&#39; = [] def format(self) -&amp;gt; str: substitute_symbol_dic: str[str] = {&#39;&amp;lt;&#39;: &#39;&amp;amp;lt;&#39;, &#39;&amp;gt;&#39;: &#39;&amp;amp;gt;&#39;, &#39;&amp;amp;&#39;: &#39;&amp;amp;amp;&#39;} temp_token: str = self.token if self.token in substitute_symbol_dic.keys(): temp_token = substitute_symbol_dic[self.token] substitute_type_dic: str[str] = {&#39;string_const&#39;: &#39;stringConstant&#39;, &#39;int_const&#39;: &#39;integerConstant&#39;} temp_token_type = self.token_type.lower() if temp_token_type in substitute_type_dic.keys(): temp_token_type = substitute_type_dic[temp_token_type] output = f&#39;&amp;lt;{temp_token_type}&amp;gt; {temp_token} &amp;lt;/{temp_token_type}&amp;gt;&#39; if len(self.before) != 0: output = &#39;\\n&#39;.join(self.before) + &#39;\\n&#39; + output if len(self.after) != 0: output += &#39;\\n&#39; + &#39;\\n&#39;.join(self.after) return outputclass JackTokenizer: def __init__(self, p_file: str) -&amp;gt; None: self.p_file = p_file with open(p_file) as f: s: str = f.read() s = re.sub(r&#39;(//.*\\n|/\\*.(.|\\s)*?\\*/)&#39;, &#39;\\n&#39;, s) # delete comments s = re.sub(r&#39; *\\n&#39;, &#39;\\n&#39;, s) # delete spaces at the end of lines self.lines: list[str] = s.split(&#39;\\n&#39;) self.lines = [line for line in self.lines if not re.match(r&#39;^\\s*$&#39;, line)] self.current_line_num: int = 0 self.line_num: int = len(self.lines) self.output: str = &#39;&amp;lt;tokens&amp;gt;\\n&#39; self.token_objects: list[TokenObject] = [] def tokenizeLine(self, line: str) -&amp;gt; &#39;list[TokenObject]&#39;: token_objects: list[TokenObject] = [] token: str = &#39;&#39; token_type: str = &#39;&#39; len_of_list: int = len(line) idx: int = 0 beg_idx: int = 0 while idx &amp;lt; len_of_list: if line[idx] == &#39;&quot;&#39;: beg_idx = idx + 1 idx += 1 while idx &amp;lt; len_of_list: if line[idx] == &#39;&quot;&#39;: token_objects.append(TokenObject(line[beg_idx:idx], &#39;STRING_CONST&#39;)) beg_idx = idx + 1 break idx += 1 elif line[idx] in tokenDic.symbols: if beg_idx != idx: token = line[beg_idx:idx] token_type = self.tokenType(token) token_objects.append(TokenObject(token, token_type)) token_objects.append(TokenObject(line[idx], &#39;SYMBOL&#39;)) beg_idx = idx + 1 elif line[idx] == &#39; &#39; or line[idx] == &#39;\\t&#39;: if beg_idx != idx: token = line[beg_idx:idx] token_type = self.tokenType(token) token_objects.append(TokenObject(token, token_type)) beg_idx = idx + 1 idx += 1 return token_objects def tokenType(self, token) -&amp;gt; str: &quot;&quot;&quot; Determine the type of a given token &quot;&quot;&quot; if token in tokenDic.keywords: return &#39;KEYWORD&#39; elif token in tokenDic.symbols: return &#39;SYMBOL&#39; elif token.isdecimal(): if int(token) &amp;lt;= 32767: return &#39;INT_CONST&#39; else: SyntaxError(&#39;Value more than 32767 is not accepted&#39;) else: if token[0].isdecimal(): SyntaxError(&#39;Identifier starts with a number is not accepted&#39;) else: return &#39;IDENTIFIER&#39; def hasMoreLine(self) -&amp;gt; bool: return True if self.current_line_num &amp;lt; self.line_num else False def advance(self) -&amp;gt; bool: print(self.current_line_num) line: str = self.lines[self.current_line_num] token_objects = self.tokenizeLine(line) self.output += &#39;\\n&#39;.join([token_object.format() for token_object in token_objects]) + &#39;\\n&#39; self.token_objects.extend(token_objects) self.current_line_num += 1 def saveToFile(self) -&amp;gt; None: self.output += &#39;&amp;lt;/tokens&amp;gt;\\n&#39; self.path_w = f&#39;{self.p_file.parent}/{self.p_file.stem}T.xml&#39; with open(self.path_w, mode=&#39;w&#39;) as f: f.write(self.output)if __name__ == &#39;__main__&#39;: path: str = sys.argv[1] p_path: pathlib.Path = pathlib.Path(path) p_file_list: &#39;list[pathlib.Path]&#39; = [] if p_path.is_dir(): p_file_list = list(p_path.glob(&#39;**/*.jack&#39;)) else: p_file_list = [p_path] for p_file in p_file_list: tokenizer = JackTokenizer(p_file) while tokenizer.hasMoreLine(): tokenizer.advance() tokenizer.saveToFile()構文解析構文木を構築するため、再帰下降構文解析を行う (この言葉かっこよくて好きだ)。最初のトークンだけからトークンの種類を決定することができる文法を LL(1) といい、Jack 言語は概ねこれに従っている。例えば他の言語だと返り値無しの関数実行は a.run() とかになるが、Jack では do a.run() などと明示することによって、先読みすることなくこれが SubroutineCall であることが分かるようになっている。パーサを作るにあたっての留意点は括弧の処理である。例えば while 文 &#39;while&#39; &#39;(&#39; expression &#39;)&#39; &#39;{&#39; statements &#39;}&#39; という形で表されるが、expression や statements の中にも当然括弧が入りうるので、対応するものを正しく見つける必要がある。今回は、0 で初期化した変数を用意し、文字列を先頭から走査しつつ ( を見つけたら +1、) を見つけたら -1 していき、変数が 0 になったところを閉じ括弧とみなす方法を採用した。AtCoder の茶 diff くらいにありそうな問題だ。def findClosingBracket(self, start: int, end: int, open_c: str, close_c: str) -&amp;gt; int: bracket_cnt: int = 0 idx: int = start while idx &amp;lt;= end: if self.token_objects[idx].token == open_c: bracket_cnt += 1 elif self.token_objects[idx].token == close_c: bracket_cnt -= 1 if bracket_cnt == 0: return idx idx += 1 return -1基本的に p233-234 の仕様通りに書いていけばよいが、expression (式) の扱いでやや混乱した。expression は term (op term)* という形で表され、要は term が op を介して組み合わさっているという形 (具体的には、1 + 1 とか sum + a[0] + f(3) とか) なので、オペレータを見つけ次第 term として分割し、そのあとの文字列を再帰で処理することになる。全体的にゴリゴリの再帰を書くことになり結構疲れた。なんやかんやできたので達成感はある。import pathlibimport sysfrom tokenizer import TokenObject, JackTokenizerclass CompilationEngine: def __init__(self, token_objects: &#39;list[TokenObject]&#39;, p_file: str) -&amp;gt; None: self.token_objects = token_objects self.p_file = p_file self.statement_keyword_dic = { &#39;let&#39;: self.compileLet, &#39;if&#39;: self.compileIf, &#39;while&#39;: self.compileWhile, &#39;do&#39;: self.compileDo, &#39;return&#39;: self.compileReturn} self.output = &#39;&#39; pass def compile(self): print(len(self.token_objects) - 1) self.compileClasses(0, len(self.token_objects) - 1) def compileClasses(self, start: int, end_script: int): &quot;&quot;&quot; Compile classes (whole script) recursively &quot;&quot;&quot; if start &amp;gt;= end_script: return closing_class_idx = self.compileClass(start, end_script) print(self.token_objects[closing_class_idx].token) return self.compileClasses(closing_class_idx + 1, end_script) def compileClass(self, start: int, end_script: int): &quot;&quot;&quot; &#39;class&#39; className &#39;{&#39; classVarDec* subroutineDec* &#39;}&#39; ex) class Bar {...} &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;class&amp;gt;&#39;) print(self.token_objects[start + 1].token) closing_class_body_idx: int = self.findClosingBracket(start + 2, end_script, &#39;{&#39;, &#39;}&#39;) self.compileClassBody(start + 3, closing_class_body_idx - 1) self.token_objects[closing_class_body_idx].after.append(&#39;&amp;lt;/class&amp;gt;&#39;) return closing_class_body_idx def compileClassBody(self, start: int, end_class_body: int): &quot;&quot;&quot; classVarDec* subroutineDec* &#39;static int a; method int hoge (...) {...}&#39; &quot;&quot;&quot; if start &amp;gt;= end_class_body: return first_token: str = self.token_objects[start].token if first_token in [&#39;static&#39;, &#39;field&#39;]: end_idx: int = self.compileClassVarDec(start, end_class_body) else: end_idx: int = self.compileSubroutineDec(start, end_class_body) return self.compileClassBody(end_idx + 1, end_class_body) def compileClassVarDec(self, start: int, end_class_body: int) -&amp;gt; int: &quot;&quot;&quot; (&#39;static&#39; | &#39;field&#39;) type varName (&#39;,&#39; varName) * &#39;;&#39; ex) &#39;static int a;&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;classVarDec&amp;gt;&#39;) print(self.token_objects[start + 1].token) idx: int = start while idx &amp;lt;= end_class_body: if self.token_objects[idx].token == &#39;;&#39;: break idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;/classVarDec&amp;gt;&#39;) return idx def compileSubroutineDec(self, start: int, end_class_body: int) -&amp;gt; int: &quot;&quot;&quot; (&#39;constructor&#39; | &#39;function&#39; | &#39;method&#39;) (&#39;void&#39; | type) subroutineName &#39;(&#39; parameterList &#39;)&#39; &#39;{&#39; subroutineBody &#39;}&#39; ex) &#39;method int hoge (...) {...}&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;subroutineDec&amp;gt;&#39;) print(self.token_objects[start + 2].token) # compile &#39;(&#39; parameterList &#39;)&#39; closing_param_list_idx: int = self.findClosingBracket(start + 3, end_class_body, &#39;(&#39;, &#39;)&#39;) self.compileParameterList(start + 4, closing_param_list_idx - 1) # compile &#39;{&#39; subroutineBody &#39;}&#39; self.token_objects[closing_param_list_idx + 1].before.append(&#39;&amp;lt;subroutineBody&amp;gt;&#39;) closing_subr_body_idx: int = self.findClosingBracket(closing_param_list_idx + 1, end_class_body, &#39;{&#39;, &#39;}&#39;) self.token_objects[closing_subr_body_idx].after.append(&#39;&amp;lt;/subroutineBody&amp;gt;&#39;) self.compileSubroutineBody(closing_param_list_idx + 2, closing_subr_body_idx - 1) self.token_objects[closing_subr_body_idx].after.append(&#39;&amp;lt;/subroutineDec&amp;gt;&#39;) return closing_subr_body_idx def compileSubroutineBody(self, start: int, end_body: int) -&amp;gt; None: &quot;&quot;&quot; varDec* statements ex) &#39;var int a; let a = 1; return a;&#39; &quot;&quot;&quot; if start &amp;gt;= end_body: return first_token: str = self.token_objects[start].token if first_token == &#39;var&#39;: end_idx: int = self.compileVarDec(start, end_body) return self.compileSubroutineBody(end_idx + 1, end_body) else: self.token_objects[start].before.append(&#39;&amp;lt;statements&amp;gt;&#39;) end_idx: int = self.compileStatements(start, end_body) self.token_objects[end_body].after.append(&#39;&amp;lt;/statements&amp;gt;&#39;) return def compileSubroutineCall(self, start: int, end: int) -&amp;gt; None: &quot;&quot;&quot; subroutineName &#39;(&#39; expressionList &#39;)&#39; | (className | varName) &#39;.&#39; subroutineName &#39;(&#39; expressionList &#39;)&#39; ex) &#39;run()&#39;, &#39;a.run()&#39; &quot;&quot;&quot; # self.token_objects[start].before.append(&#39;&amp;lt;term&amp;gt;&#39;) idx: int = start while self.token_objects[idx].token != &#39;(&#39;: idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;expressionList&amp;gt;&#39;) closing_expression_list = self.findClosingBracket(idx, end, &#39;(&#39;, &#39;)&#39;) self.compileExpressionList(idx + 1, closing_expression_list - 1) self.token_objects[closing_expression_list].before.append(&#39;&amp;lt;/expressionList&amp;gt;&#39;) # self.token_objects[end].after.append(&#39;&amp;lt;/term&amp;gt;&#39;) def compileExpressionList(self, start: int, end: int) -&amp;gt; None: &quot;&quot;&quot; (expression (&#39;,&#39; expression)*)? ex) &#39;(a + 1, b)&#39; &quot;&quot;&quot; if start &amp;gt; end: return idx: int = start exp_start_idx: int = start while idx &amp;lt;= end: if self.token_objects[idx].token == &#39;,&#39;: self.compileExpression(exp_start_idx, idx - 1) exp_start_idx = idx + 1 idx += 1 self.compileExpression(exp_start_idx, end) def compileParameterList(self, start: int, end: int): &quot;&quot;&quot; ((type varName) (&#39;,&#39; type varName)*)? ex) &#39;int a, char c&#39;, &#39;&#39; &quot;&quot;&quot; if start &amp;gt; end: self.token_objects[end].after.append(&#39;&amp;lt;parameterList&amp;gt;&#39;) self.token_objects[start].before.append(&#39;&amp;lt;/parameterList&amp;gt;&#39;) else: self.token_objects[start].before.append(&#39;&amp;lt;parameterList&amp;gt;&#39;) self.token_objects[end].after.append(&#39;&amp;lt;/parameterList&amp;gt;&#39;) def compileVarDec(self, start: int, end_body: int) -&amp;gt; int: &quot;&quot;&quot; &#39;var&#39; type varName (&#39;,&#39; varname)* &#39;;&#39; ex) &#39;int a, b;&#39;; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;varDec&amp;gt;&#39;) idx: int = start while idx &amp;lt;= end_body: if self.token_objects[idx].token == &#39;;&#39;: break idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;/varDec&amp;gt;&#39;) return idx def compileStatements(self, start: int, end_statements: int) -&amp;gt; None: if start &amp;gt;= end_statements: return first_token: str = self.token_objects[start].token end_statement: int = self.statement_keyword_dic[first_token](start, end_statements) self.compileStatements(end_statement + 1, end_statements) def compileDo(self, start: int, end_statements: int) -&amp;gt; int: &quot;&quot;&quot; &#39;do&#39; subroutineCall &#39;;&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;doStatement&amp;gt;&#39;) idx: int = start while idx &amp;lt;= end_statements: if self.token_objects[idx].token == &#39;;&#39;: break idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;/doStatement&amp;gt;&#39;) self.compileSubroutineCall(start + 1, idx - 1) return idx def compileLet(self, start: int, end_statements: int) -&amp;gt; int: &quot;&quot;&quot; &#39;let&#39; varname (&#39;[&#39; expression &#39;]&#39;)? &#39;=&#39; expression &#39;;&#39; ex) &#39;let a = 5;&#39;, &#39;let a[4] = b + 3;&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;letStatement&amp;gt;&#39;) right_operand_start_idx: int = None if self.token_objects[start + 2].token == &#39;[&#39;: # if &#39;[&#39; expression &#39;]&#39; closing_expression_idx: int = self.findClosingBracket(start + 2, end_statements, &#39;[&#39;, &#39;]&#39;) self.compileExpression(start + 3, closing_expression_idx - 1) right_operand_start_idx = closing_expression_idx + 2 else: right_operand_start_idx = start + 3 idx: int = right_operand_start_idx while idx &amp;lt;= end_statements: if self.token_objects[idx].token == &#39;;&#39;: break idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;/letStatement&amp;gt;&#39;) self.compileExpression(right_operand_start_idx, idx - 1) return idx def compileWhile(self, start: int, end_statements: int) -&amp;gt; int: &quot;&quot;&quot; &#39;while&#39; &#39;(&#39; expression &#39;)&#39; &#39;{&#39; statements &#39;}&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;whileStatement&amp;gt;&#39;) # (expression) closing_expression_idx: int = self.findClosingBracket(start + 1, end_statements, &#39;(&#39;, &#39;)&#39;) self.compileExpression(start + 2, closing_expression_idx - 1) # {statements} closing_statements_idx: int = self.findClosingBracket(closing_expression_idx + 1, end_statements, &#39;{&#39;, &#39;}&#39;) self.token_objects[closing_expression_idx + 2].before.append(&#39;&amp;lt;statements&amp;gt;&#39;) self.compileStatements(closing_expression_idx + 2, closing_statements_idx - 1) self.token_objects[closing_statements_idx - 1].after.append(&#39;&amp;lt;/statements&amp;gt;&#39;) self.token_objects[closing_statements_idx].after.append(&#39;&amp;lt;/whileStatement&amp;gt;&#39;) return closing_statements_idx def compileReturn(self, start: int, end_statements: int) -&amp;gt; int: &quot;&quot;&quot; &#39;return&#39; expression? &#39;;&#39; &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;returnStatement&amp;gt;&#39;) idx: int = start while idx &amp;lt;= end_statements: if self.token_objects[idx].token == &#39;;&#39;: break idx += 1 self.token_objects[idx].after.append(&#39;&amp;lt;/returnStatement&amp;gt;&#39;) if idx - start &amp;gt; 1: self.compileExpression(start + 1, idx - 1) return idx def findClosingBracket(self, start: int, end: int, open_c: str, close_c: str) -&amp;gt; int: bracket_cnt: int = 0 idx: int = start while idx &amp;lt;= end: if self.token_objects[idx].token == open_c: bracket_cnt += 1 elif self.token_objects[idx].token == close_c: bracket_cnt -= 1 if bracket_cnt == 0: return idx idx += 1 print(&#39;not found&#39;) def compileIf(self, start, end_statements) -&amp;gt; int: &quot;&quot;&quot; &#39;if&#39; &#39;(&#39; expression &#39;)&#39; &#39;{&#39; statements &#39;}&#39; (&#39;else&#39; &#39;{&#39; statements &#39;}&#39;)? &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;ifStatement&amp;gt;&#39;) # (expression) closing_expression_idx: int = self.findClosingBracket(start + 1, end_statements, &#39;(&#39;, &#39;)&#39;) self.compileExpression(start + 2, closing_expression_idx - 1) # {statements} closing_statements_idx: int = self.findClosingBracket(closing_expression_idx + 1, end_statements, &#39;{&#39;, &#39;}&#39;) self.token_objects[closing_expression_idx + 2].before.append(&#39;&amp;lt;statements&amp;gt;&#39;) self.compileStatements(closing_expression_idx + 2, closing_statements_idx - 1) self.token_objects[closing_statements_idx - 1].after.append(&#39;&amp;lt;/statements&amp;gt;&#39;) # else if (closing_statements_idx == end_statements) or ( self.token_objects[closing_statements_idx + 1].token != &#39;else&#39;): self.token_objects[closing_statements_idx].after.append(&#39;&amp;lt;/ifStatement&amp;gt;&#39;) return closing_statements_idx # {statements} closing_else_statements_idx: int = self.findClosingBracket(closing_statements_idx + 2, end_statements, &#39;{&#39;, &#39;}&#39;) self.token_objects[closing_statements_idx + 3].before.append(&#39;&amp;lt;statements&amp;gt;&#39;) self.compileStatements(closing_statements_idx + 3, closing_else_statements_idx - 1) self.token_objects[closing_else_statements_idx - 1].after.append(&#39;&amp;lt;/statements&amp;gt;&#39;) self.token_objects[closing_else_statements_idx].after.append(&#39;&amp;lt;/ifStatement&amp;gt;&#39;) return closing_else_statements_idx def compileExpression(self, start: int, end_exp: int) -&amp;gt; None: &quot;&quot;&quot; term (op term)* &quot;&quot;&quot; self.token_objects[start].before.append(&#39;&amp;lt;expression&amp;gt;&#39;) if start &amp;gt; end_exp: return idx: int = start while idx &amp;lt;= end_exp: # print(idx, end_exp) idx = self.compileTerm(idx, end_exp) idx += 1 if self.token_objects[idx].token in [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;&amp;amp;&#39;, &#39;|&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;=&#39;]: idx += 1 self.token_objects[end_exp].after.append(&#39;&amp;lt;/expression&amp;gt;&#39;) def compileTerm(self, start: int, end_exp: int) -&amp;gt; None: self.token_objects[start].before.append(&#39;&amp;lt;term&amp;gt;&#39;) first_token: str = self.token_objects[start].token print(first_token) end_idx: int = start if end_exp - start &amp;lt; 1: end_idx = end_exp # &#39;(&#39; expression &#39;)&#39; if first_token == &#39;(&#39;: closing_term: int = self.findClosingBracket(start, end_exp, &#39;(&#39;, &#39;)&#39;) self.compileExpression(start + 1, closing_term - 1) end_idx = closing_term # unaryOp elif first_token in [&#39;-&#39;, &#39;~&#39;]: closing_right_operand: int = self.compileTerm(start + 1, end_exp) end_idx = closing_right_operand # varName &#39;[&#39; expression &#39;]&#39; elif self.token_objects[start + 1].token == &#39;[&#39;: closing_term: int = self.findClosingBracket(start, end_exp, &#39;[&#39;, &#39;]&#39;) self.compileExpression(start + 2, closing_term - 1) end_idx = closing_term # subroutineName &#39;(&#39; expressionList &#39;)&#39; elif self.token_objects[start + 1].token == &#39;(&#39;: print(&#39;subroutine&#39;) closing_term: int = self.findClosingBracket(start + 1, end_exp, &#39;(&#39;, &#39;)&#39;) self.compileSubroutineCall(start, closing_term) end_idx = closing_term # (className | varName) &#39;.&#39; subroutineName &#39;(&#39; expressionList &#39;)&#39; elif self.token_objects[start + 1].token == &#39;.&#39;: print(&#39;subroutine&#39;) closing_term: int = self.findClosingBracket(start + 3, end_exp, &#39;(&#39;, &#39;)&#39;) self.compileSubroutineCall(start, closing_term) end_idx = closing_term self.token_objects[end_idx].after.append(&#39;&amp;lt;/term&amp;gt;&#39;) return end_idx def saveToFile(self) -&amp;gt; None: self.output += &#39;\\n&#39;.join([token_object.format() for token_object in self.token_objects]) + &#39;\\n&#39; self.path_w = f&#39;{self.p_file.parent}/{self.p_file.stem}.xml&#39; with open(self.path_w, mode=&#39;w&#39;) as f: f.write(self.output)if __name__ == &#39;__main__&#39;: path: str = sys.argv[1] p_path: pathlib.Path = pathlib.Path(path) p_file_list: &#39;list[pathlib.Path]&#39; = [] if p_path.is_dir(): p_file_list = list(p_path.glob(&#39;**/*.jack&#39;)) else: p_file_list = [p_path] for p_file in p_file_list: print(p_file) tokenizer = JackTokenizer(p_file) while tokenizer.hasMoreLine(): tokenizer.advance() compiler = CompilationEngine(tokenizer.token_objects, p_file) compiler.compile() compiler.saveToFile()" }, { "title": "コンピュータシステムの理論と実装 (9)", "url": "/posts/nand2tetris-09.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Jack, nand2tetris, Book Review", "date": "2022-01-15 00:00:00 +0900", "snippet": "9 章: 高水準言語高水準言語 Jack から VM 言語への変換を行うにあたって、ここで Jack 言語 (Java の簡易版みたいなもの) の仕様を一通りみておく。変数の種類とスコープ変数には以下の 3 つのほか、サブルーチン宣言のときのパラメータリストなどがある。 スタティック変数: あるクラスのすべてのオブジェクトで共有される変数。static で宣言。 フィールド変数: あるオブジェクト内で共有される変数。field で宣言。これが C++ や Python でいうメンバ変数である。 ローカル変数: サブルーチン内のみをスコープにもつ変数。var で宣言。クラスとサブルーチン Jack のプログラムには Main という名前のクラスが含まれる必要がある (C++ で int main が必要なのと一緒だ)。 1 つのクラスには main という名前の function が定義されなくてはならない。 サブルーチンには constructor, method, function の 3 種類がある。method はクラスから生成されたオブジェクトに対して動作し、C++ や Python などでのメンバ関数に該当する。一方、function はオブジェクトに依存せず動作するものであるっぽい。このあたりの話は Java をやっていればしっくりくる話なのかもしれないが、ほぼ全く書いたことがないので結構戸惑った。class Hoge { // Hoge 型を返すコンストラクタ。new というのは慣例的な名前であり、C 言語の new とかとは異なる constructor Hoge new() method void fuga() function int piyo() // function はクラスのメンバ関数を使わず、生成されたオブジェクトに依存しない method void foo() { // --- method の実行 --- // 特に返り値のない関数を実行するときは do をつける do fuga(); // method は同じクラス内で特に何もつけずに呼ぶことができる // --- function の実行 --- var int a; // 返り値がある場合、事前に返り値を格納する変数を宣言しておかなくてはならない let a = Hoge.piyo(); // function を呼ぶときはクラス名を頭につけなくてはいけない }}class Main { function void main { var Hoge obj; // --- クラス外からの constructor の実行 --- let obj = Hoge.new(); // クラス名.関数名とする // --- クラス外からの method の実行 --- do obj.fuga(); // オブジェクト依存なので、オブジェクト名.関数名 // --- クラス外からの function の実行 --- var int a; let a = Hoge.piyo(); // クラス名.関数名 }}課題Jack に慣れるため、なんでもいいから書いてみようとの課題。試しに A - New Generation ABC を解いてみたのが以下のコードである。class Main { function void main() { var int s; let s = Keyboard.readInt(&quot;&quot;); if (s &amp;lt; 126) { do Output.printInt(4); } else { if (s &amp;lt; 212) { do Output.printInt(6); } else { do Output.printInt(8); } } return; }}" }, { "title": "コンピュータシステムの理論と実装 (8)", "url": "/posts/nand2tetris-08.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Compiler, Jack, Python, nand2tetris, Book Review", "date": "2022-01-15 00:00:00 +0900", "snippet": "前章で作成した VM translator に追加して、本章ではプログラム制御 (サブルーチンの呼び出しやメモリ割り当てなど) を実装していく。8 章 バーチャルマシン #2: プログラム制御プログラムフローコマンドまず面倒なのが if go-to コマンドのコンパイルである。これはスタックトップの値を pop して (これは前章までの内容でいける) 0 でなければ (TRUE であれば) 指定されたラベルに飛ぶ形になる。例えば以下のようなループを考える。label LOOP_START...if go-to LOOP_STARTこの vm コードを変換すると、以下のようなアセンブリを生成するようにする。(LOOP_START)...@SPA = M - 1D = M // まずはスタックトップの値を D に格納しておく@SP M = M - 1 // decement SP@TRUE1D;JNE// when D is zero (go downwards)...(TRUE1) // when D is not zero (jump to LOOP_START)@LOOP_START0;JMP関数呼び出しコマンド次にかなり厄介なのが関数呼び出しに伴う一連の実装とメモリ管理である。基本的に p178, p179 の図と疑似コードを見ながら慎重に書いていくのがよい。まず関数を呼び出す時点で以下の作業をしておく必要がある。 呼び出す関数の引数 n 個をまずプッシュする。 関数から出たあとに戻ってくるラベル (リターンアドレス) を指定。@return_address みたいにラベルを置いておくだけでよい。 呼び出し側の関数内の状態を保存するために、現在の LCL, ARG, THIS, THAT をこの順に push しておく。 ARG が指す位置を新しい関数向けに更新する。1 でプッシュした引数の 0 個目 (SP - n - 5) が新たな ARG になる。 LCL が指す位置を新しい関数向けに更新する。これは現在のスタックポインタの位置になる。 新しい関数のラベルに移動する。 この行に戻ってきたいので、(return-address) を置いておく。以上の作業が、call f n のコンパイル時に行われる。呼び出された関数 function f k の側では次の処理をすることになる。 関数名のラベルを置いておく。(f) としておけばよい。 k 個のローカル変数をすべて 0 で初期化する。pop constant 0 と pop local i を k 回繰り返せばよい。一番ややこしいのが関数からのリターンである。 もとの変数のリターンアドレスを適当な変数 @ret などに格納する。リターンアドレスが格納されている位置自体は *(LCL) - 5 である。 関数の戻り値を *(ARG) の位置に格納する。関数から出たあとは、返り値のアドレス = ARG が指しているアドレスとなる。 スタックポインタを *(ARG) + 1 の位置に変更する。関数から出たあとは、スタックポインタは返り値の次のアドレスを指すようになる。 THAT, THIS, ARG, LCL を元の値に復元する。 リターンアドレスにジャンプする。@ret; A = M; 0;JMP と問答無用で跳ぶようにする。以上の作業でハマったのが、1 を 4 より先に行っておくべきという点である。もしローカル引数が 0 個の場合 ARG が指すアドレスとリターンアドレスが格納されているメモリの位置が同じになってしまい、4 で ARG を更新するついでにリターンアドレスが更新されてすごいことになってしまう。これに気づくのに半日程度かかって悲しい気持ちに。ブートストラップコード同じディレクトリにあるすべての .vm に対して上記の作業を行い、一つの .asm ファイルを生成するようにする。ブートストラップコード (スタックポインタを 256 に設定する、call Sys.init する) を付け加えれば、おしまい！import reimport pathlibimport sysclass CodeWriter: def __init__(self, p_path: pathlib.Path) -&amp;gt; None: if p_path.is_dir(): self.path_w = f&#39;{p_path}/{p_path.stem}.asm&#39; else: self.path_w = p_path.with_suffix(&#39;.asm&#39;) print(self.path_w) self.dic = { &#39;local&#39;: &#39;@LCL&#39;, &#39;argument&#39;: &#39;@ARG&#39;, &#39;this&#39;: &#39;@THIS&#39;, &#39;that&#39;: &#39;@THAT&#39;, &#39;pointer&#39;: &#39;@3&#39;, &#39;temp&#39;: &#39;@5&#39;, } self.snippets = { &#39;increment_sp&#39;: [&#39;@SP&#39;, &#39;M = M + 1&#39;], &#39;decrement_sp&#39;: [&#39;@SP&#39;, &#39;M = M - 1&#39;], &#39;copy_d_to_stack_top&#39;: [&#39;@SP&#39;, &#39;A = M&#39;, &#39;M = D&#39;], &#39;from_stack_top_value_to_d&#39;: [&#39;@SP&#39;, &#39;A = M&#39;, &#39;D = M&#39;], &#39;update_address_to_top&#39;: [&#39;@SP&#39;, &#39;A = M&#39;], &#39;move_address_backward&#39;: [&#39;A = A - 1&#39;] } self.appendix: str = &#39;&#39; self.appendix_idx: int = 0 self.output: str = &#39;&#39; self.return_address_idx: int = 0 self.ret_idx: int = 0 self.addOutputLines([&#39;@256&#39;, &#39;D = A&#39;, &#39;@SP&#39;, &#39;M = D&#39;]) self.processCall(&#39;Sys.init&#39;, 0) def setFileName(self, p_file: pathlib.Path) -&amp;gt; None: self.filename: str = p_file.stem # get filename def processPush(self, arg1: str, arg2: str) -&amp;gt; None: if arg1 == &#39;constant&#39;: # Place num to stack top. ex) &#39;push constant 2&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;]) elif arg1 == &#39;static&#39;: # Place the value of a symbol to stack top. ex) &#39;push static 1&#39; # Create the name of the symbol. ex) &#39;@filename.1&#39; self.addOutputLines([f&#39;@{self.filename}.{arg2}&#39;, &#39;D = M&#39;]) elif arg1 == &#39;pointer&#39; or arg1 == &#39;temp&#39;: # Place the address of this (pointer[0]) or that (pointer[1]) to stack top. ex) &#39;push pointer 1&#39;, or # Place the value of temp to stack top. ex) &#39;push temp 1&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;, f&#39;{self.dic[arg1]}&#39;, &#39;A = A + D&#39;, &#39;D = M&#39;]) else: # argument, local, this, that # Place the value of the specified segment[idx] to stack top. ex) &#39;push argument 3&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;, f&#39;{self.dic[arg1]}&#39;, &#39;A = M + D&#39;, &#39;D = M&#39;]) self.addOutputLines(self.snippets[&#39;copy_d_to_stack_top&#39;] + self.snippets[&#39;increment_sp&#39;]) def processPop(self, arg1: str, arg2: str) -&amp;gt; None: self.addOutputLines(self.snippets[&#39;decrement_sp&#39;] + self.snippets[&#39;from_stack_top_value_to_d&#39;]) if arg1 == &#39;constant&#39;: # Remove num from stack top. ex) &#39;pop constant 2&#39; # Is &#39;pop constant&#39; possible in .vm file? self.addOutputLines([f&#39;@{str(arg2)}&#39;, &#39;M = D&#39;]) elif arg1 == &#39;static&#39;: # Place the value of a stack top to a symbol. ex) &#39;pop static 1&#39; # Create the name of the symbol. ex) &#39;@filename.1&#39; self.addOutputLines([f&#39;@{self.filename}.{arg2}&#39;, &#39;M = D&#39;]) else: forward_A_arg2_times: list[str] = [&#39;A = A + 1&#39; for _ in range(int(arg2))] if arg1 == &#39;pointer&#39; or arg1 == &#39;temp&#39;: # Place the value of the stack top to this (pointer[0]) or that (pointer[1]). ex) &#39;pop pointer 1&#39;, or # Place the value of the stack top to temp. ex) &#39;pop temp 1&#39; self.addOutputLines([f&#39;{self.dic[arg1]}&#39;] + forward_A_arg2_times + [&#39;M = D&#39;]) else: # argument, local, this, that # Place the value of the stack top to specified segment[idx]. ex) &#39;pop argument 3&#39; self.addOutputLines([f&#39;{self.dic[arg1]}&#39;, &#39;A = M&#39;] + forward_A_arg2_times + [&#39;M = D&#39;]) def processArithmetric(self, command: str) -&amp;gt; None: if command == &#39;neg&#39; or command == &#39;not&#39;: self.addOutputLines(self.snippets[&#39;update_address_to_top&#39;] + self.snippets[&#39;move_address_backward&#39;]) self.addOutputLines([&#39;M = -M&#39;] if command == &#39;neg&#39; else [&#39;M = !M&#39;]) return self.addOutputLines( self.snippets[&#39;decrement_sp&#39;] + self.snippets[&#39;from_stack_top_value_to_d&#39;] # set the value of the second operand to D + self.snippets[&#39;move_address_backward&#39;]) # move address to the first operand if command == &#39;add&#39;: self.addOutputLines([&#39;M = M + D&#39;]) elif command == &#39;sub&#39;: self.addOutputLines([&#39;M = M - D&#39;]) elif command == &#39;and&#39;: self.addOutputLines([&#39;M = D &amp;amp; M&#39;]) elif command == &#39;or&#39;: self.addOutputLines([&#39;M = D | M&#39;]) else: # eq, gt, lt self.addOutputLines([&#39;D = M - D&#39;, f&#39;@TRUE{self.appendix_idx}&#39;]) if command == &#39;eq&#39;: self.addOutputLines([&#39;D;JEQ&#39;]) if command == &#39;gt&#39;: self.addOutputLines([&#39;D;JGT&#39;]) if command == &#39;lt&#39;: self.addOutputLines([&#39;D;JLT&#39;]) # If false, write 0 (false) to the top of the stuck self.addOutputLines([&#39;@SP&#39;, &#39;A = M - 1&#39;, &#39;M = 0&#39;, f&#39;(BACK{str(self.appendix_idx)})&#39;]) # If true, write -1 (true) to the top of the stuck self.addAppendixLines([f&#39;(TRUE{self.appendix_idx})&#39;, &#39;@SP&#39;, &#39;A = M - 1&#39;, &#39;M = -1&#39;, f&#39;@BACK{str(self.appendix_idx)}&#39;, &#39;0;JMP&#39;]) self.appendix_idx += 1 def processLabel(self, arg1: str) -&amp;gt; None: # ex) label loop self.addOutputLines([f&#39;({arg1})&#39;]) def processGoto(self, arg1: str) -&amp;gt; None: # ex) goto loop self.addOutputLines([f&#39;@{arg1}&#39;, &#39;0;JMP&#39;]) def processIfGoto(self, arg1: str) -&amp;gt; None: # ex) if-goto loop self.addOutputLines([&#39;@SP&#39;, &#39;A = M - 1&#39;, &#39;D = M&#39;] + self.snippets[&#39;decrement_sp&#39;] + [f&#39;@TRUE{self.appendix_idx}&#39;, &#39;D;JNE&#39;]) self.addAppendixLines([f&#39;(TRUE{self.appendix_idx})&#39;] + [f&#39;@{arg1}&#39;, &#39;0;JMP&#39;]) self.appendix_idx += 1 def processFunction(self, arg1: str, arg2: str) -&amp;gt; None: self.addOutputLines([f&#39;({arg1})&#39;]) for i in range(int(arg2)): self.processPush(&#39;constant&#39;, 0) self.processPop(&#39;local&#39;, i) def processReturn(self) -&amp;gt; None: updateAddressToOriginal = lambda label, times: self.addOutputLines( [&#39;@LCL&#39;, &#39;A = M&#39;] + [&#39;A = A - 1&#39; for _ in range(times)] + [&#39;D = M&#39;, f&#39;@{label}&#39;, &#39;M = D&#39;]) # Place return value to argument 0 updateAddressToOriginal(f&#39;ret{self.ret_idx}&#39;, 5) # ret = *(LCL - 5) self.processPop(&#39;argument&#39;, &#39;0&#39;) # *ARG = pop() self.addOutputLines([&#39;@ARG&#39;, &#39;D = M + 1&#39;, &#39;@SP&#39;, &#39;M = D&#39;]) # SP = ARG + 1 # updateAddressToOriginal(f&#39;ret&#39;, 5) # ret = *(LCL - 5) updateAddressToOriginal(&#39;THAT&#39;, 1) # THAT = *(LCL - 1) updateAddressToOriginal(&#39;THIS&#39;, 2) # THIS = *(LCL - 2) updateAddressToOriginal(&#39;ARG&#39;, 3) # ARG = *(LCL - 3) updateAddressToOriginal(&#39;LCL&#39;, 4) # LCL = *(LCL - 4) # self.addOutputLines([f&#39;@ret&#39;, &#39;A = M&#39;, &#39;0;JMP&#39;]) # goto ret self.addOutputLines([f&#39;@ret{self.ret_idx}&#39;, &#39;A = M&#39;, &#39;0;JMP&#39;]) # goto ret self.ret_idx += 1 def processCall(self, arg1: str, arg2: str): # self.processPush(&#39;constant&#39;, self.getLineNum() + 50 + int(arg2)) # push return_address # arg2 = max(int(arg2), 1) self.addOutputLines( [f&#39;@return_address_{self.return_address_idx}&#39;, &#39;D = A&#39;] + self.snippets[&#39;copy_d_to_stack_top&#39;] + self.snippets[&#39;increment_sp&#39;]) # push return-address pushLabel = lambda label: self.addOutputLines( [f&#39;@{label}&#39;, &#39;D = M&#39;] + self.snippets[&#39;copy_d_to_stack_top&#39;] + self.snippets[&#39;increment_sp&#39;]) pushLabel(&#39;LCL&#39;) # push LCL pushLabel(&#39;ARG&#39;) # push ARG pushLabel(&#39;THIS&#39;) # push THIS pushLabel(&#39;THAT&#39;) # push THAT self.addOutputLines([&#39;@SP&#39;, &#39;D = M&#39;] + [&#39;D = D - 1&#39; for _ in range(int(arg2) + 5)] + [&#39;@ARG&#39;, &#39;M = D&#39;]) # ARG = SP - arg2 - 5 self.addOutputLines([&#39;@SP&#39;, &#39;D = M&#39;, &#39;@LCL&#39;, &#39;M = D&#39;]) # LCL = SP self.processGoto(arg1) # goto f self.addOutputLines([f&#39;(return_address_{self.return_address_idx})&#39;]) self.return_address_idx += 1 def getLineNum(self) -&amp;gt; int: return len(self.output.split(&#39;\\n&#39;)) def addOutputLines(self, lines: &#39;list[str]&#39;) -&amp;gt; None: self.output += &#39;\\n&#39;.join(lines) + &#39;\\n&#39; def addAppendixLines(self, lines: &#39;list[str]&#39;) -&amp;gt; None: self.appendix += &#39;\\n&#39;.join(lines) + &#39;\\n&#39; def saveToFile(self) -&amp;gt; None: if self.appendix != &#39;&#39;: self.output += &#39;@END\\n0;JMP\\n&#39; + self.appendix + &#39;(END)\\n&#39; with open(self.path_w, mode=&#39;w&#39;) as f: f.write(self.output)class Parser: def __init__(self, path: str) -&amp;gt; None: self.path: str = path self.p_file = pathlib.Path(self.path) with open(path) as f: s: str = f.read() s = re.sub(r&#39;//.*\\n&#39;, &#39;\\n&#39;, s) # delete comments s = re.sub(r&#39; *\\n&#39;, &#39;\\n&#39;, s) # delete spaces at the end of lines self.lines: list[str] = s.split(&#39;\\n&#39;) self.lines = [line for line in self.lines if line != &#39;&#39;] # delete black lines self.line = self.lines[0] self.line_num = len(self.lines) self.current_line_num = 0 def commandType(self) -&amp;gt; str: &quot;&quot;&quot; Determine command type from a line &quot;&quot;&quot; command: str = self.line.split(&#39; &#39;)[0] if command == &#39;push&#39;: return &#39;C_PUSH&#39; elif command == &#39;pop&#39;: return &#39;C_POP&#39; elif command == &#39;label&#39;: return &#39;C_LABEL&#39; elif command == &#39;goto&#39;: return &#39;C_GOTO&#39; elif command == &#39;if-goto&#39;: return &#39;C_IF&#39; elif command == &#39;function&#39;: return &#39;C_FUNCTION&#39; elif command == &#39;return&#39;: return &#39;C_RETURN&#39; elif command == &#39;call&#39;: return &#39;C_CALL&#39; else: return &#39;C_ARITHMETIC&#39; def arg1(self) -&amp;gt; str: &quot;&quot;&quot; Returns the first argument &quot;&quot;&quot; tmp = self.line.split(&#39; &#39;) if len(tmp) != 1: # ex) &#39;local&#39; in &#39;push local 0&#39; return tmp[1] else: # When C_ARITHMETIC, the command itself is returned. ex) &#39;add&#39; return tmp[0] def arg2(self) -&amp;gt; str: &quot;&quot;&quot; Returns the second argument. This is called only when &#39;C_PUSH&#39;, &#39;C_POP&#39;, &#39;C_FUNCTION&#39;, or &#39;C_CALL&#39; &quot;&quot;&quot; # ex) &#39;0&#39; in &#39;push local 0&#39; tmp = self.line.split(&#39; &#39;) return tmp[2] def hasMoreCommands(self) -&amp;gt; bool: return True if self.current_line_num &amp;lt; self.line_num else False def advance(self) -&amp;gt; bool: print(self.current_line_num) self.line = self.lines[self.current_line_num] self.current_line_num += 1if __name__ == &#39;__main__&#39;: path: str = sys.argv[1] p_path: pathlib.Path = pathlib.Path(path) p_file_list: &#39;list[pathlib.Path]&#39; = [] if p_path.is_dir(): p_file_list = list(p_path.glob(&#39;**/*.vm&#39;)) else: p_file_list = [p_path] writer = CodeWriter(p_path) for p_file in p_file_list: parser = Parser(p_file) writer.setFileName(p_file) while parser.hasMoreCommands(): parser.advance() command_type: str = parser.commandType() if command_type == &#39;C_ARITHMETIC&#39;: writer.processArithmetric(parser.arg1()) elif command_type == &#39;C_PUSH&#39;: writer.processPush(parser.arg1(), parser.arg2()) elif command_type == &#39;C_POP&#39;: writer.processPop(parser.arg1(), parser.arg2()) elif command_type == &#39;C_LABEL&#39;: writer.processLabel(parser.arg1()) elif command_type == &#39;C_GOTO&#39;: writer.processGoto(parser.arg1()) elif command_type == &#39;C_IF&#39;: writer.processIfGoto(parser.arg1()) elif command_type == &#39;C_FUNCTION&#39;: writer.processFunction(parser.arg1(), parser.arg2()) elif command_type == &#39;C_RETURN&#39;: writer.processReturn() elif command_type == &#39;C_CALL&#39;: writer.processCall(parser.arg1(), parser.arg2()) print(parser.arg1(), &#39;,&#39;, parser.arg2()) writer.saveToFile()感想関数の呼び出しとか今まで本当に何も考えずにやっていたけど、メモリ管理も含めてめちゃくちゃ苦労した。p180 にある functionName$label、どの関数の中に入っているか保持して作業するのあまりにも面倒すぎて実装をサボったのだけど普通にテストを通ってしまった。いつかこれで痛い目をみるのだろうか。" }, { "title": "コンピュータシステムの理論と実装 (7)", "url": "/posts/nand2tetris-07.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Compiler, Jack, Python, nand2tetris, Book Review", "date": "2022-01-15 00:00:00 +0900", "snippet": "前章でアセンブリ言語からバイナリへの変換ができるようになったため、次は一段階上がってコンパイラを書いていく。本書では Jack という簡易版 Java みたいな高水準言語の処理系を実装していくことになるのだが、これはまず中間コード (VM コード) を経てアセンブリ言語に変換される形式を採っている。7 章および 8 章では、VM コードをアセンブリ言語に変換する VM translator を作成する。7 章 バーチャルマシン #1: スタック操作メモリセグメント操作この章ではスタック操作を扱う。スタックポインタを SP とすると、例えば push constant 2 のように、定数の 2 をスタックのトップに追加する場合は以下のように変換すればよい。*(*(SP)) = 2 という操作をしたあとで、スタックポインタをインクリメントする形になる。@2D = A@SPA = MM = D@SPM = M + 1この VM には local というセグメントがあり、関数内で定義されたローカル変数は local セグメント (ベースアドレスは @LCL で指定されている) でアクセスできるようになる。例えば pop local 2 は *(*(@LCL) + 2) をスタックのトップにある値で更新する形になる。これをアセンブリ言語で書くと、次のような問題が発生する。// --- この前にスタックポインタをデクリメントする操作が入る ---@SPA = MD = M // ここでスタックトップの値を D に格納@2// ここでいつも通り D = 2 としたいが、そうすると上で格納した D の値が上書きされてしまう最初にこの本を読んだ際はなんか適当なシンボルを新たに定義してそこを一時的な退避場所として指定していたが、強い人のコード を見たところ @2 とせずに以下の方法で解決していた。なるほど確かに。@LCLA = A + 1A = A + 1 // 単に定数の回数だけ A をインクリメントすればよいM = D// --- この後にスタックをデクリメントする操作が入る ---また、この VM では pointer というセグメントが用意されており、pointer 0 は this を、pointer 1 は that を指す。例えば pop pointer 0 の場合だと this のベースアドレス (RAM[3] に格納されている値) をスタックの一番上にある値で更新することになる。ややこしいが、pop that 0 の場合は that が指しているアドレスの値 をスタックの一番上の値で更新することになるので注意。定数でもローカル変数でもポインタでもないものは static で宣言することになっており、例えば hoge.vm にある push static 3 は@hoge.3D = M// 以下、D をスタックにプッシュする処理のように変換される。これは何か static というセグメントが存在してそれの 3 番目ということではなく、単に一意になるようシンボルを命名しているだけである。スタック算術add, sub, and, or はいいとして問題は大小比較を行う演算子である。条件分岐を行い、true の場合はスタックトップに -1 を、false の場合は 0 を格納することになる。例えば eq の場合以下のようなコードを目指すことになる。@SPM = M - 1 // decrement SP@SPD = M // first operandA = A - 1D = M - D // second - first@TRUE1D;JEQ@SP // false A = M - 1M = 0(BACK1)...(TRUE1) // trueA = M - 1M = -1@BACK10;JMP2 項演算子ならスタックポインタをデクリメントする必要があるが、neg や not ではその必要がないので注意。完成したコード以上まとめると次のようになる。import reimport pathlibimport sysclass CodeWriter: def __init__(self, path) -&amp;gt; None: self.setFileName(path) self.dic = { &#39;local&#39;: &#39;@LCL&#39;, &#39;argument&#39;: &#39;@ARG&#39;, &#39;this&#39;: &#39;@THIS&#39;, &#39;that&#39;: &#39;@THAT&#39;, &#39;pointer&#39;: &#39;@3&#39;, &#39;temp&#39;: &#39;@5&#39;, } self.snippets = { &#39;increment_sp&#39;: [&#39;@SP&#39;, &#39;M = M + 1&#39;], &#39;decrement_sp&#39;: [&#39;@SP&#39;, &#39;M = M - 1&#39;], &#39;copy_d_to_stack_top&#39;: [&#39;@SP&#39;, &#39;A = M&#39;, &#39;M = D&#39;], &#39;from_stack_top_value_to_d&#39;: [&#39;@SP&#39;, &#39;A = M&#39;, &#39;D = M&#39;], &#39;update_address_to_top&#39;: [&#39;@SP&#39;, &#39;A = M&#39;], &#39;move_address_backward&#39;: [&#39;A = A - 1&#39;] } self.output: str = &#39;&#39; self.appendix: str = &#39;&#39; self.appendix_idx: int = 0 def setFileName(self, path) -&amp;gt; None: self.p_file = pathlib.Path(path) self.filename: str = self.p_file.stem # get filename self.path_w = self.p_file.with_suffix(&#39;.asm&#39;) def processPush(self, arg1: str, arg2: str) -&amp;gt; None: if arg1 == &#39;constant&#39;: # Place num to stack top. ex) &#39;push constant 2&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;]) elif arg1 == &#39;static&#39;: # Place the value of a symbol to stack top. ex) &#39;push static 1&#39; # Create the name of the symbol. ex) &#39;@filename.1&#39; self.addOutputLines([f&#39;@{self.filename}.{arg2}&#39;, &#39;D = M&#39;]) elif arg1 == &#39;pointer&#39; or arg1 == &#39;temp&#39;: # Place the address of this (pointer[0]) or that (pointer[1]) to stack top. ex) &#39;push pointer 1&#39;, or # Place the value of temp to stack top. ex) &#39;push temp 1&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;, f&#39;{self.dic[arg1]}&#39;, &#39;A = A + D&#39;, &#39;D = M&#39;]) else: # argument, local, this, that # Place the value of the specified segment[idx] to stack top. ex) &#39;push argument 3&#39; self.addOutputLines([f&#39;@{arg2}&#39;, &#39;D = A&#39;, f&#39;{self.dic[arg1]}&#39;, &#39;A = M + D&#39;, &#39;D = M&#39;]) self.addOutputLines(self.snippets[&#39;copy_d_to_stack_top&#39;] + self.snippets[&#39;increment_sp&#39;]) def processPop(self, arg1: str, arg2: str) -&amp;gt; None: self.addOutputLines(self.snippets[&#39;decrement_sp&#39;] + self.snippets[&#39;from_stack_top_value_to_d&#39;]) if arg1 == &#39;constant&#39;: # Remove num from stack top. ex) &#39;pop constant 2&#39; # Is &#39;pop constant&#39; possible in .vm file? self.addOutputLines([f&#39;@{str(arg2)}&#39;, &#39;M = D&#39;]) elif arg1 == &#39;static&#39;: # Place the value of a stack top to a symbol. ex) &#39;pop static 1&#39; # Create the name of the symbol. ex) &#39;@filename.1&#39; self.addOutputLines([f&#39;@{self.filename}.{arg2}&#39;, &#39;M = D&#39;]) else: forward_A_arg2_times: list[str] = [&#39;A = A + 1&#39; for _ in range(int(arg2))] if arg1 == &#39;pointer&#39; or arg1 == &#39;temp&#39;: # Place the value of the stack top to this (pointer[0]) or that (pointer[1]). ex) &#39;pop pointer 1&#39;, or # Place the value of the stack top to temp. ex) &#39;pop temp 1&#39; self.addOutputLines([f&#39;{self.dic[arg1]}&#39;] + forward_A_arg2_times + [&#39;M = D&#39;]) else: # argument, local, this, that # Place the value of the stack top to specified segment[idx]. ex) &#39;pop argument 3&#39; self.addOutputLines([f&#39;{self.dic[arg1]}&#39;, &#39;A = M&#39;] + forward_A_arg2_times + [&#39;M = D&#39;]) def processArithmetric(self, command: str) -&amp;gt; None: if command == &#39;neg&#39; or command == &#39;not&#39;: self.addOutputLines(self.snippets[&#39;update_address_to_top&#39;] + self.snippets[&#39;move_address_backward&#39;]) self.addOutputLines([&#39;M = -M&#39;] if command == &#39;neg&#39; else [&#39;M = !M&#39;]) return self.addOutputLines( self.snippets[&#39;decrement_sp&#39;] + self.snippets[&#39;from_stack_top_value_to_d&#39;] # set the value of the second operand to D + self.snippets[&#39;move_address_backward&#39;]) # move address to the first operand if command == &#39;add&#39;: self.addOutputLines([&#39;M = M + D&#39;]) elif command == &#39;sub&#39;: self.addOutputLines([&#39;M = M - D&#39;]) elif command == &#39;and&#39;: self.addOutputLines([&#39;M = D &amp;amp; M&#39;]) elif command == &#39;or&#39;: self.addOutputLines([&#39;M = D | M&#39;]) else: # eq, gt, lt self.addOutputLines([&#39;D = M - D&#39;, f&#39;@TRUE{self.appendix_idx}&#39;]) if command == &#39;eq&#39;: self.addOutputLines([&#39;D;JEQ&#39;]) if command == &#39;gt&#39;: self.addOutputLines([&#39;D;JGT&#39;]) if command == &#39;lt&#39;: self.addOutputLines([&#39;D;JLT&#39;]) # If false, write 0 (false) to the top of the stuck self.addOutputLines([&#39;@SP&#39;, &#39;A = M - 1&#39;, &#39;M = 0&#39;, f&#39;(BACK{str(self.appendix_idx)})&#39;]) # If true, write -1 (true) to the top of the stuck self.addAppendixLines([f&#39;(TRUE{self.appendix_idx})&#39;, &#39;@SP&#39;, &#39;A = M - 1&#39;, &#39;M = -1&#39;, f&#39;@BACK{str(self.appendix_idx)}&#39;, &#39;0;JMP&#39;]) self.appendix_idx += 1 def addOutputLines(self, lines: &#39;list[str]&#39;) -&amp;gt; None: self.output += &#39;\\n&#39;.join(lines) + &#39;\\n&#39; def addAppendixLines(self, lines: &#39;list[str]&#39;) -&amp;gt; None: self.appendix += &#39;\\n&#39;.join(lines) + &#39;\\n&#39; def saveToFile(self) -&amp;gt; None: if self.appendix != &#39;&#39;: self.output += &#39;@END\\n0;JMP\\n&#39; + self.appendix + &#39;(END)\\n&#39; with open(self.path_w, mode=&#39;w&#39;) as f: f.write(self.output)class Parser: def __init__(self, path: str) -&amp;gt; None: self.path: str = path self.p_file = pathlib.Path(self.path) with open(path) as f: s: str = f.read() s = re.sub(r&#39;//.*\\n&#39;, &#39;\\n&#39;, s) # delete comments s = re.sub(r&#39; *\\n&#39;, &#39;\\n&#39;, s) # delete spaces at the end of lines self.lines: list[str] = s.split(&#39;\\n&#39;) self.lines = [line for line in self.lines if line != &#39;&#39;] # delete black lines self.line = self.lines[0] self.line_num = len(self.lines) self.current_line_num = 0 def commandType(self) -&amp;gt; str: &quot;&quot;&quot; Determine command type from a line &quot;&quot;&quot; command: str = self.line.split(&#39; &#39;)[0] if command == &#39;push&#39;: return &#39;C_PUSH&#39; elif command == &#39;pop&#39;: return &#39;C_POP&#39; elif command == &#39;label&#39;: return &#39;C_label&#39; elif command == &#39;goto&#39;: return &#39;C_GOTO&#39; elif command == &#39;if-goto&#39;: return &#39;C_IF&#39; elif command == &#39;function&#39;: return &#39;C_FUNCTION&#39; elif command == &#39;return&#39;: return &#39;C_RETURN&#39; elif command == &#39;call&#39;: return &#39;C_CALL&#39; else: return &#39;C_ARITHMETIC&#39; def arg1(self) -&amp;gt; str: &quot;&quot;&quot; Returns the first argument &quot;&quot;&quot; tmp = self.line.split(&#39; &#39;) if len(tmp) != 1: # ex) &#39;local&#39; in &#39;push local 0&#39; return tmp[1] else: # When C_ARITHMETIC, the command itself is returned. ex) &#39;add&#39; return tmp[0] def arg2(self) -&amp;gt; str: &quot;&quot;&quot; Returns the second argument. This is called only when &#39;C_PUSH&#39;, &#39;C_POP&#39;, &#39;C_FUNCTION&#39;, or &#39;C_CALL&#39; &quot;&quot;&quot; # ex) &#39;0&#39; in &#39;push local 0&#39; tmp = self.line.split(&#39; &#39;) return tmp[2] def hasMoreCommands(self) -&amp;gt; bool: return True if self.current_line_num &amp;lt; self.line_num else False def advance(self) -&amp;gt; bool: print(self.current_line_num) self.line = self.lines[self.current_line_num] self.current_line_num += 1if __name__ == &#39;__main__&#39;: path: str = sys.argv[1] parser = Parser(path) writer = CodeWriter(path) while parser.hasMoreCommands(): parser.advance() command_type: str = parser.commandType() if command_type == &#39;C_ARITHMETIC&#39;: writer.processArithmetric(parser.arg1()) elif command_type == &#39;C_PUSH&#39;: writer.processPush(parser.arg1(), parser.arg2()) elif command_type == &#39;C_POP&#39;: writer.processPop(parser.arg1(), parser.arg2()) writer.saveToFile()感想大昔 C 言語をかじったときはポインタのポインタとか具体的に何の役に立つのか全然分からなかったけど、こうして処理系を頑張って自作してみると必要性が実感できてよい。低レイヤは楽しいね。" }, { "title": "競プロ用環境構築のメモ", "url": "/posts/competitive-programming-environment.html", "categories": "Technology, Competitive Programming", "tags": "VSCode, Environment Setup", "date": "2022-01-10 00:00:00 +0900", "snippet": "久々に競プロ環境を整備し直したのでメモしておく。以下、WSL2 (Ubuntu 18.04.1) と VSCode という環境下で、C++17 を用いて問題を解く際の環境設定を記載する。VSCode のエディタ設定 昨年 9 月のアップデートから公式で提供されるようになった editor.bracketPairColorization.enabled を用いれば対応する括弧の色付けができ、さらに editor.guides.bracketPairs でペアの対応範囲がカラーガイドで示されるようになる。 settings.json への記載内容は以下の通り。{ &quot;editor.guides.bracketPairs&quot;: true, &quot;editor.bracketPairColorization.enabled&quot;: true, &quot;[cpp]&quot;: { &quot;editor.tabSize&quot;: 2 }, &quot;editor.formatOnSave&quot;: true, &quot;files.autoSave&quot;: &quot;afterDelay&quot;,}コードスニペットの登録 こちらのレポジトリ (Fork 元からほぼ変更していない) をクローンし snippets/gen.py を実行。src フォルダ内にある C++ ファイルの // snippet-begin と // snippet-end に挟まれた部分を抽出したうえで、C++ のスニペット用ファイル /mnt/c/Users/iwasaki/AppData/Roaming/Code/User/snippets/cpp.json を上書きし、ファイル名をキーとするスニペットとして使えるようになる。 ほか、スニペットにわざわざ登録するほどでもないちょっとした tips などは Boostnote に書いている。最新版ではコードスニペット機能がなくなってしまった (Markdown しか書けなくなってしまった？) ようなのでしゃーなし Legacy 0.16.1 を使っているのだけど、ほぼ同等の機能をもつ massCode に鞍替えしようかと検討中。拡張機能設定競プロ関係で用いている拡張機能は以下の通り。 Remote - WSL Visual Studio IntelliCode Competitive Programming Helper (cph) C/C++ Code Runner macrosCompetitive Programming Helper (cph) 競プロに特化した拡張機能。Google Chrome に Competitive Companion をインストールすると「問題のタイトルをファイル名にした新規ソースコードファイルを作成 + 問題文をパースしてサンプル入出力をダウンロード + サイドパネルに表示」してくれる。 コードを実行し所要時間および各サンプルに対する正誤を表示してくれるのはもちろんのこと、手動でテストケースを追加してまとめてテストすることも可能である。至れり尽くせり。 実際の GUI はこんな感じ。 コードを実行するとこのように表示される。 コンパイルオプションを設定することもできる。{ &quot;cph.language.cpp.Args&quot;: &quot;-std=c++17&quot;,}C/C++公式から提供されている拡張機能をインストールする。C_Cpp.clang_format_fallbackStyle での指定を行うとお好みのスタイルで上手いこと整形してくれるので非常に便利。個人的には括弧の補完で改行をしないようにしたい派なので、Google スタイルを採用している。{ &quot;C_Cpp.default.intelliSenseMode&quot;: &quot;gcc-x64&quot;, &quot;C_Cpp.default.cppStandard&quot;: &quot;c++17&quot;, &quot;C_Cpp.default.cStandard&quot;: &quot;c11&quot;, &quot;C_Cpp.clang_format_fallbackStyle&quot;: &quot;Google&quot;, &quot;C_Cpp.default.compilerPath&quot;: &quot;/usr/bin/g++&quot;,}Code Runner 開いているソースコードのファイルの言語を判別し、任意のコマンドを実行できる拡張機能。C++ の場合は「ソースコードのディレクトリに入る → お気に入りのオプションを付け g++ でコンパイル → バイナリをターミナルで実行」をショートカットキー (デフォルトでは Ctrl + Alt + N) 一つで行うことができかなり時短になる。 上記のほかもう一つ customCommand を決めることができるので「ソースコードのディレクトリに入る → バイナリをターミナルで実行」という動作を設定している。(コンパイルに時間がかかるような巨大なファイルは書かないのであまり関係ないといえばないのだけど) 再コンパイルせずに別のサンプルを与えて出力をみたいだけのときに重宝する。こちらは Ctrl + Alt + K で実行できる。{ &quot;code-runner.runInTerminal&quot;: true, &quot;code-runner.executorMap&quot;: { &quot;c&quot;: &quot;cd $dir &amp;amp;&amp;amp; gcc $fileName -o $fileNameWithoutExt -lm &amp;amp;&amp;amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;amp;&amp;amp; g++ -std=c++17 -Wall -Wextra -Wshadow -D_GLIBCXX_DEBUG -fsanitize=undefined -DLOCAL -fsplit-stack $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&quot;, &quot;python&quot;: &quot;cd $dir &amp;amp;&amp;amp; python3.8 $fileName&quot;, }, &quot;code-runner.customCommand&quot;: &quot;cd $dir &amp;amp;&amp;amp; $dir$fileNameWithoutExt&quot;,}macros 上記の Code Runner を使えばターミナルでバイナリの実行まで済ませてはくれるのだが、一度ターミナルにフォーカスを合わせてからサンプルを貼り付けるという微妙なひと手間が発生するのが気に入らない。このような場合、複数の VSCode コマンドを一つのコマンドにまとめられる拡張機能 macros が有効である。例えば以下のように設定すれば、runCpp や execCpp というコマンドに対してショートカットを設定し先述の作業を一発で実行できるようになる。{ &quot;macros&quot;: { &quot;runCpp&quot;: [ &quot;code-runner.run&quot;, &quot;workbench.action.terminal.focus&quot; ], &quot;execCpp&quot;: [ &quot;code-runner.runCustomCommand&quot;, &quot;workbench.action.terminal.focus&quot; ],} 上記は便利なのではあるが、拡張機能のソースコードで非同期処理が壊れている影響で、時間のかかる処理をフローの中に入れた場合順番がめちゃくちゃになってしまう問題がある。以前 別の記事 にも書いた通り現在でも修正されていないため、/home/ubuntu/.vscode-server/extensions/geddski.macros-1.2.1/extension.js を こちら に差し替える必要がある。 ほかには以下のようなマクロを設定している。cout_endl は、cout &amp;lt;&amp;lt; &amp;lt;&amp;lt; endl を入力したうえでカーソルを真ん中に持っていきたいという怠惰の極みのようなコマンドである。temp は競プロ用テンプレートを貼ったうえで、コード入力開始位置にカーソルを持ってくるためのものである。書き方がダサすぎるのが少し残念。 { &quot;macros&quot;: { &quot;cout_endl&quot;: [ { &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;args&quot;: { &quot;langId&quot;: &quot;cpp&quot;, &quot;name&quot;: &quot;output&quot; } }, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot;, &quot;cursorLeft&quot; ], &quot;temp&quot;: [ { &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;args&quot;: { &quot;langId&quot;: &quot;cpp&quot;, &quot;name&quot;: &quot;template&quot; } }, &quot;cursorUp&quot;, &quot;cursorUp&quot;, &quot;cursorUp&quot;, &quot;cursorRight&quot; ], }}ショートカットキーの設定上記で設定したマクロに対してショートカットキーを設定して、おしまい！[ { &quot;key&quot;: &quot;ctrl+alt+n&quot;, &quot;command&quot;: &quot;macros.runCpp&quot; }, { &quot;key&quot;: &quot;ctrl+alt+k&quot;, &quot;command&quot;: &quot;macros.execCpp&quot; }, { &quot;key&quot;: &quot;ctrl+o ctrl+p&quot;, &quot;command&quot;: &quot;macros.cout_endl&quot; }, { &quot;key&quot;: &quot;ctrl+k ctrl+p&quot;, &quot;command&quot;: &quot;macros.temp&quot; },]" }, { "title": "コンピュータシステムの理論と実装 (6)", "url": "/posts/nand2tetris-06.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Python, Hack, nand2tetris, Assembly, Book Review", "date": "2022-01-09 00:00:00 +0900", "snippet": "6 章 アセンブラ前章までで CPU や Computer の実装が終わり、ハードウェアは完成した。次はソフトウェア部分ということで、一番下のレイヤであるアセンブラを書いていく。この章以降は HDL から離れて好きな言語でコードを書けることになるため、文字列操作に慣れた Python を使うことにした。コマンドの判別本書で用いられている機械語は 1 行 1 コマンドであり、@ で開始する A 命令、() で囲まれた L 命令、その他の C 命令のいずれかであるかを判定する必要がある。これは各行の最初の文字を見れば簡単に可能である。L 命令の処理 例えば (LOOP) という L 命令と @LOOP という A 命令があったとする。A 命令の方が先に登場した場合、まだシンボルテーブルに追加されていないため対応する ROM アドレスに変換することができない。そこで、1 周目の処理でまず L 命令を処理してしまい、そこで作成されたシンボルテーブルを用いて 2 周目で全体の変換を行う方針とする。 本書では機械語とバイナリで行数が変わらないため、ROM アドレスには現在の実行ファイルの行数を指定しておけばよい。A 命令の処理 @ の後に続くものが 32678 以下の数字であるなら、当該数字をバイナリに変換するだけでよい。その他の場合はまずシンボルテーブルを検索し、存在しなければ項目を追加することになる。新規シンボルには、まだ割り当てられていない RAM アドレスのうち最も若いものを割り振るようにする。 シンボルには予約語 (SCREEN, SP, R0 など) が存在するため、変換開始前に登録しておく必要がある。C 命令の処理 まあまあややこしかったので専用のクラスを作ることにした。111 から開始するのはいいとして、そのあとは comp 領域、dest 領域、jump 領域に分けて実装していくことになる。 jump 領域は ; の右側、dest 領域は = の左側、comp 領域は = の右側に依存しているので、地道にそれぞれの処理を書いていけばよい。この部分に限ったことではないけど、正しいコードを正しくパースして変換できるようにするだけでも大変なのに、このうえ Syntax error を検知するのはめちゃくちゃきついなという実感があった。例えば下の自作アセンブラは M = A = 1 みたいなあからさまに間違った機械語が書かれていた場合でも一応アセンブル自体は通ってしまうわけで、世の中のちゃんとしたアセンブラ/コンパイラ/インタプリタ書いてる人はちゃんと例外処理をしたうえで人間に理解可能なエラーメッセージを出力していて本当にえらいという気持ちに。実装上記をまとめると以下のようになる。import reimport pathlibimport configimport sysclass CParser(): def __init__(self, line: str, binary_list: &#39;list[int]&#39;) -&amp;gt; None: self.line = line self.binary_list = binary_list def updateDbit(self) -&amp;gt; None: &quot;&quot;&quot; Update binary_list when dest exists (when &#39;=&#39; is in the line) &quot;&quot;&quot; if &#39;=&#39; not in self.line: return # Extract left side of the &#39;=&#39; (dest) mnemonic: str = self.line.split(&#39;=&#39;)[0] # if mnemonic == &#39;null&#39;: # return if &#39;A&#39; in mnemonic: self.binary_list[10] = 1 if &#39;D&#39; in mnemonic: self.binary_list[11] = 1 if &#39;M&#39; in mnemonic: self.binary_list[12] = 1 def updateCbit(self) -&amp;gt; None: &quot;&quot;&quot; Update binary_list following the C bits in the line &quot;&quot;&quot; # extract between &#39;=&#39; and &#39;;&#39; mnemonic: str = self.line if &#39;=&#39; in mnemonic: mnemonic = self.line.split(&#39;=&#39;)[1] if &#39;;&#39; in mnemonic: mnemonic = mnemonic.split(&#39;;&#39;)[0] # binary[3] (a) is 1 if comp contains &#39;M&#39; if &#39;M&#39; in mnemonic: self.binary_list[3] = 1 # Convert &#39;M&#39; to &#39;A&#39; in order to refer to comp_dic mnemonic = mnemonic.replace(&#39;M&#39;, &#39;A&#39;) # Refer to comp_dic and fill in the comp binary b: str = config.comp_dic[mnemonic] for i in range(6): self.binary_list[i + 4] = str(b[i]) def updateJbit(self) -&amp;gt; None: &quot;&quot;&quot; Update binary_list when jump exists (when &#39;;&#39; is in the line) &quot;&quot;&quot; if &#39;;&#39; not in self.line: return mnemonic: str = self.line.split(&#39;;&#39;)[1] b = config.jump_dic[mnemonic] self.binary_list[13] = str(b[0]) self.binary_list[14] = str(b[1]) self.binary_list[15] = str(b[2]) def process(self) -&amp;gt; &#39;list[int]&#39;: # The first three bits are 1 self.binary_list[0] = self.binary_list[1] = self.binary_list[2] = 1 # Update other bits self.updateDbit() self.updateCbit() self.updateJbit() return self.binary_listclass Parser: def __init__(self, path: str) -&amp;gt; None: self.path: str = path with open(path) as f: s: str = f.read() s = s.replace(&#39; &#39;, &#39;&#39;) # delete whitespaces s = re.sub(r&#39;//.*\\n&#39;, &#39;\\n&#39;, s) # delete comments self.lines: list[str] = [line for line in s.split(&#39;\\n&#39;) if line != &#39;&#39;] # split by \\n and delete black lines self.symbol_dic: dict[str, str] = config.symbol_dic self.clearCache() def clearCache(self) -&amp;gt; None: self.output: str = &quot;&quot; self.output_file_row_idx: int = 0 self.next_memory_idx: int = 16 def combertNumToBinaryStr(self, num: int) -&amp;gt; str: bin_str: str = format(num, &#39;b&#39;) return bin_str.rjust(16, &#39;0&#39;) def commandType(self) -&amp;gt; str: if self.line[0] == &#39;@&#39;: return &#39;A_COMMAND&#39; elif self.line[0] == &#39;(&#39;: return &#39;L_COMMAND&#39; else: return &#39;C_COMMAND&#39; def extractSymbol(self) -&amp;gt; str: # Extract symbol str from L_COMMAND or A_COMMAND return self.line.translate(str.maketrans({&#39;(&#39;: &#39;&#39;, &#39;)&#39;: &#39;&#39;, &#39;@&#39;: &#39;&#39;})) def processC(self) -&amp;gt; str: &quot;&quot;&quot; Process lines that start with neither &#39;@&#39; nor &#39;(&#39; &quot;&quot;&quot; c_parser_obj = CParser(self.line, self.binary_list) self.binary_list = c_parser_obj.process() return &#39;&#39;.join([str(i) for i in self.binary_list]) def processA(self) -&amp;gt; str: &quot;&quot;&quot; Process lines that start with &#39;@&#39; &quot;&quot;&quot; # Extract symbol str symbol_mnemonic: str = self.extractSymbol() # If the input is like &#39;@10&#39; if symbol_mnemonic.isdecimal(): # If the number is more than 32678, it is invalid as an ROM address and is regarded as a symbol if int(symbol_mnemonic) &amp;lt; 32768: bin_str = self.combertNumToBinaryStr(int(symbol_mnemonic)) return bin_str # If the input is a symbol like &#39;@i&#39; or &#39;@40000&#39; # If already exist in symbol dic if symbol_mnemonic in self.symbol_dic: return self.symbol_dic[symbol_mnemonic] # If new symbol bin_str = self.combertNumToBinaryStr(self.next_memory_idx) self.symbol_dic[symbol_mnemonic] = bin_str self.next_memory_idx += 1 return bin_str def processL(self) -&amp;gt; None: &quot;&quot;&quot; Process lines that start with &#39;(&#39; &quot;&quot;&quot; # Extract symbol str symbol_mnemonic: str = self.extractSymbol() # Convert the ROM address to binary string bin_str: str = self.combertNumToBinaryStr(self.output_file_row_idx) # Update symbol_dic self.symbol_dic[symbol_mnemonic] = bin_str def saveToFile(self) -&amp;gt; None: p_file = pathlib.Path(self.path) path_w: pathlib.Path = p_file.with_suffix(&#39;.hack&#39;) with open(path_w, mode=&#39;w&#39;) as f: f.write(self.output) def firstRun(self) -&amp;gt; None: # In the first run, only L_COMMAND is processed for line in self.lines: self.line = line if line[0] == &#39;(&#39;: self.processL() else: self.output_file_row_idx += 1 self.clearCache() return def secondRun(self) -&amp;gt; None: for line in self.lines: self.line = line self.binary_list: list[int] = [0 for _ in range(16)] command_type: str = self.commandType() if command_type == &#39;L_COMMAND&#39;: continue # If not L_COMMAND, one row will be added to the output file self.output_file_row_idx += 1 result: str = &#39;&#39; if command_type == &#39;C_COMMAND&#39;: result = self.processC() else: result = self.processA() self.output += result + &#39;\\n&#39; self.saveToFile() self.clearCache() returnif __name__ == &#39;__main__&#39;: path = sys.argv[1] parser_obj = Parser(path) parser_obj.firstRun() parser_obj.secondRun()デフォルトのシンボルテーブルや予約語処理用辞書は別ファイルにまとめて同ディレクトリに置いておくことにする。jump_dic = { &#39;null&#39;: &#39;000&#39;, &#39;JGT&#39;: &#39;001&#39;, &#39;JEQ&#39;: &#39;010&#39;, &#39;JGE&#39;: &#39;011&#39;, &#39;JLT&#39;: &#39;100&#39;, &#39;JNE&#39;: &#39;101&#39;, &#39;JLE&#39;: &#39;110&#39;, &#39;JMP&#39;: &#39;111&#39;}comp_dic = { &#39;D|A&#39;: &#39;010101&#39;, &#39;D&amp;amp;A&#39;: &#39;000000&#39;, &#39;A-D&#39;: &#39;000111&#39;, &#39;D-A&#39;: &#39;010011&#39;, &#39;D+A&#39;: &#39;000010&#39;, &#39;A+D&#39;: &#39;000010&#39;, &#39;A-1&#39;: &#39;110010&#39;, &#39;D-1&#39;: &#39;001110&#39;, &#39;A+1&#39;: &#39;110111&#39;, &#39;1+A&#39;: &#39;110111&#39;, &#39;D+1&#39;: &#39;011111&#39;, &#39;1+D&#39;: &#39;011111&#39;, &#39;-A&#39;: &#39;110011&#39;, &#39;-D&#39;: &#39;001111&#39;, &#39;!A&#39;: &#39;110001&#39;, &#39;!D&#39;: &#39;001101&#39;, &#39;A&#39;: &#39;110000&#39;, &#39;D&#39;: &#39;001100&#39;, &#39;-1&#39;: &#39;111010&#39;, &#39;1&#39;: &#39;111111&#39;, &#39;0&#39;: &#39;101010&#39;,}symbol_dic = { &#39;SP&#39;: &#39;0000000000000000&#39;, &#39;LCL&#39;: &#39;0000000000000001&#39;, &#39;ARG&#39;: &#39;0000000000000010&#39;, &#39;THIS&#39;: &#39;0000000000000011&#39;, &#39;THAT&#39;: &#39;0000000000000100&#39;, &#39;R0&#39;: &#39;0000000000000000&#39;, &#39;R1&#39;: &#39;0000000000000001&#39;, &#39;R2&#39;: &#39;0000000000000010&#39;, &#39;R3&#39;: &#39;0000000000000011&#39;, &#39;R4&#39;: &#39;0000000000000100&#39;, &#39;R5&#39;: &#39;0000000000000101&#39;, &#39;R6&#39;: &#39;0000000000000110&#39;, &#39;R7&#39;: &#39;0000000000000111&#39;, &#39;R8&#39;: &#39;0000000000001000&#39;, &#39;R9&#39;: &#39;0000000000001001&#39;, &#39;R10&#39;: &#39;0000000000001010&#39;, &#39;R11&#39;: &#39;0000000000001011&#39;, &#39;R12&#39;: &#39;0000000000001100&#39;, &#39;R13&#39;: &#39;0000000000001101&#39;, &#39;R14&#39;: &#39;0000000000001110&#39;, &#39;R15&#39;: &#39;0000000000001111&#39;, &#39;SCREEN&#39;: &#39;0100000000000000&#39;, &#39;KBD&#39;: &#39;0110000000000000&#39;}検証本章では、自作アセンブラが吐いたバイナリと付属の正しいアセンブラが吐いたバイナリの diff をみることによるデバッグが必要となる。少し作業を楽にするための tips として以下のようなものが有効であった。 付属のアセンブラが吐いたバイナリを git commit しておき、diff をエディタ上で確認できるようにしておく 以下のようなシェルスクリプトを置いておき、複数ファイルの出力をまとめてテストできるようにしておくpython -u &quot;Assembler.py&quot; ./add/Add.asmpython -u &quot;Assembler.py&quot; ./max/MaxL.asmpython -u &quot;Assembler.py&quot; ./max/Max.asmpython -u &quot;Assembler.py&quot; ./pong/PongL.asmpython -u &quot;Assembler.py&quot; ./pong/Pong.asmpython -u &quot;Assembler.py&quot; ./rect/RectL.asmpython -u &quot;Assembler.py&quot; ./rect/Rect.asm" }, { "title": "コンピュータシステムの理論と実装 (5)", "url": "/posts/nand2tetris-05.html", "categories": "Technology, Low-Level", "tags": "Low-Level, HDL, nand2tetris, Book Review", "date": "2022-01-05 00:00:00 +0900", "snippet": "5 章 コンピュータアーキテクチャ本章ではついにメモリ、CPU を実装していく。メモリの実装 基本的に p99 の仕様に従って書いていけばよい。まずは入力として与えられたアドレスがどのメモリマップに位置するかを判定する必要があるが、0-16383 が RAM に、16384-24575 がスクリーンに、24576 以降がキーボードに割り振られていることを考慮すると以下のような表が完成する。これらは p21 の表を参考にしつつ DMux4Way で簡単に書くことができる。出力も同様にマルチプレキサを用いればよい。   Address[14] Address[13] RAM 0 0 RAM 0 1 Screen 1 0 Keyboard 1 1 最初のデマルチプレキサ部分で a と b に同じ名前の変数を入れると怒られが発生するので (よく考えたらそりゃそうだ)、ここでは loadram0 と loadram1 という変数にそれぞれ格納したうえで、Or をとることによって RAM 入力の boolean をまとめている。CHIP Memory { IN in[16], load, address[15]; OUT out[16]; PARTS: DMux4Way(in=load, sel=address[13..14], a=loadram0, b=loadram1, c=loadsc, d=loadkey); Or(a=loadram0, b=loadram1, out=loadram); RAM16K(in=in, load=loadram, address=address[0..13], out=outram); Screen(in=in, load=loadsc, address=address[0..12], out=outsc); Keyboard(out=outkey); Mux4Way16(a=outram, b=outram, c=outsc, d=outkey, sel=address[13..14], out=out);}CPU の実装 p102 とにらめっこしながら地道に実装していくことになる。ここで作る CPU はデータレジスタ D、アドレスレジスタ A、プログラムカウンタレジスタ PC を備えている。これらのレジスタには、遠く離れた場所にあるメモリより高速にアクセスできる。 CPU に与えられるのは M value input (16 ビット)、reset (命令メモリの値をリセットする場合は 1 を与える) のほか、16 bit の命令がある。p70 で説明があったように、この命令は A 命令: 0vvvvvvvvvvvvvvv の形式。A レジスタに vvvvvvvvvvvvvvv の値を設定 C 命令: 111accccccdddjjj の形式。 acccccc の部分 (comp 領域) では実行する計算 (の数式) を指定する。1 bit 目 a では ALU が計算に A レジスタの値か M value input のどちらを用いるかを決定する。 ddd の 3bit (dest 領域) では、計算結果を A レジスタ、D レジスタ、Memory[A] にそれぞれ格納するかどうかを指定する。 jjj の部分では計算結果の正負に応じたジャンプの条件を指定 (p73 表を参照)。ジャンプする場合、アドレスは事前に A レジスタに設定しておく必要がある。 という形式になっている。とりあえず instruction[15] が 0 のとき A 命令、そうでないとき C 命令になることが分かる。 以上より、ここで A レジスタの目線に立つと次のように書ける。 A 命令である場合 instruction の値を無条件で A レジスタに設定 C 命令でありかつ instruction[5] == 1 である場合、ALU 出力を A レジスタに設定 D レジスタの目線では、C 命令でありかつ instruction[4] == 1 である場合のみ ALU 出力を D レジスタの入力に設定することになる。その他の場合は何もしなくてよい (load ビットに false を設定するようにすればよい)。 次は ALU の視点に立ってみる。 A 命令の場合は特に計算するものもないので適当に false でも出力させておく。 C 命令の場合は何らか 2 つの 16bit 値に関して計算しなくてはならない。そのうちの 1 つに D レジスタからの出力を用いるのは確定である。もう一つの入力については、a つまり instruction[12] が 0 の場合 A レジスタからの出力を、1 のときは M value input を用いる形にすればよい。 最後は PC の目線である。C 命令でありかつ ALU の出力が jump の条件 instruction[0..2] を満たしている場合のみ load させればよい。そのほかの場合は特にジャンプ操作は発生しないのでインクリメントすればよい (inc = true としておけばよい)。 この CPU の出力について。writeM が true の場合、RAM[addressM] に outM の値を設定することになる。writeM の値は、C 命令でありかつ instruction[3] == 1 であるときのみ true になる。A 命令の場合は A レジスタの値が変化するだけであり RAM の操作は絡まないので、無条件で false となる。 非常にややこしいが、上記をまとめると以下のようになる。CHIP CPU { IN inM[16], // M value input (M = contents of RAM[A]) instruction[16], // Instruction for execution reset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0). OUT outM[16], // M value output writeM, // Write to M? addressM[15], // Address in data memory (of M) pc[15]; // address of next instruction PARTS: // instruction[15] が 0 のとき A 命令、1 のとき C 命令 Mux(a=false, b=true, sel=instruction[15], out=isC); // writeM (M に書き込むかどうかの bool) を出力 And(a=instruction[3], b=isC, out=writeM); // A レジスタの処理 // instruction[5] は d ビット。A に書き込むかどうかを決定する // A 命令であるか, あるいは C 命令でかつ instruction[5] == 1 なら load する Mux(a=true, b=instruction[5], sel=isC, out=isLoadA); // A 命令なら instruction を、C 命令なら outALU を読み込む Mux16(a=instruction, b=outALU, sel=isC, out=loadobj); // 図 5-7 の A レジスタ手間のマルチプレキサ ARegister(in=loadobj, load=isLoadA, out=outA, out[0..14]=addressM); // 計算結果を D レジスタに保存する // C 命令でかつ instruction[4] == 1 であるときのみ load すればよい And(a=instruction[4], b=isC, out=loadD); DRegister(in=outALU, load=loadD, out=outD); // instruction[12] は、ALU が A レジスタかメモリ入力のどちらを操作するかを決定する (p71 図 4-3 の左右が決定される) // 0 のときは A からの出力を, 1 のときは inM を利用 Mux16(a=outA, b=inM, sel=instruction[12], out=AorM); // 図 5-7 の、ALU の手間にあるマルチプレキサ // ALU ALU(x=outD, y=AorM, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=outALU, zr=zr, ng=ng); // C 命令のとき outALU を outM として出力。A 命令の時は何を出力しても良い Mux16(a=false, b=outALU, sel=isC, out=outM); // load は ALU の出力 (outM) が jump の条件を満たしている場合に 1 となる Jump(in=instruction[0..2], zr=zr, ng=ng, out=isLoadJump); Mux(a=false, b=isLoadJump, sel=isC, out=load); // in には A レジスタからの出力が入る // load あるいは reset が 1 のときはどうせ無視されるので、inc は常に 1 でよい PC(in=outA, load=load, inc=true, reset=reset, out[0..14]=pc);}ジャンプ部分では以下の自作 CHIP を用いている。ALU から出力された zr, ng のフラグが、instruction[0..2] の内容に沿っているかを判定していけばよい。CHIP Jump { IN in[3], zr, ng; OUT out; PARTS: // 正かどうかの boolean (pg) を作っておく Or(a=zr, b=ng, out=tmp); Not(in=tmp, out=pg); // in[0] は 正、in[1] はゼロ、in[2] は負のときを表す And(a=in[2], b=ng, out=out0); And(a=in[1], b=zr, out=out1); And(a=in[0], b=pg, out=out2); // out0-2 のいずれかに該当する場合は true を返す Or(a=out0, b=out1, out=out3); Or(a=out2, b=out3, out=out);}Computer の実装やっとこさ CPU まで出来上がったところで、あとは p105 の図を参考にしつつこれらを接続するだけである。やったね……！CHIP Computer { IN reset; PARTS: ROM32K(address=pc, out=instruction); CPU(inM=inM, instruction=instruction, reset=reset, outM=outM, writeM=writeM, addressM=addressM, pc=pc); Memory(in=outM, load=writeM, address=addressM, out=inM);}" }, { "title": "コンピュータシステムの理論と実装 (4)", "url": "/posts/nand2tetris-04.html", "categories": "Technology, Low-Level", "tags": "Low-Level, Assembly, Hack, nand2tetris, Book Review", "date": "2022-01-03 00:00:00 +0900", "snippet": "4 章 機械語 本章では Hack 機械語 というアセンブリ言語を書いていく。A がそのとき指しているアドレスの値、M がアドレス A が指しているメモリワードの値、D は値を格納できる変数のようなものと考えるとわかりやすい。 基本的に 1 や 0 以外の定数をそのまま計算に使うことはできないので、例えば定数を D に代入したい場合は@5D = Mなどとするしかない。課題 下記 .asm コードを動かすためには、いったん Assembler.bat で .hack ファイルを生成したうえで、それを CPUEmulator.bat で検証する必要があるので注意。.asm コードを編集した場合その都度バイナリに変換する必要がある。 Memory[R0] および Memory[R1] に現在格納されている値を計算して、Memory[R2] に格納するプログラムを書いていく。ただの乗算であるが当然 * なんて使えるはずがないので、小学生のころの気持ちに戻ってループを回し加算を繰り返す形になる。 @i M = 1 // Memory[i] = 1 @R2 M = 0 // Memory[R2] = 0(LOOP) @i D = M // D = Memory[i] @R1 D = D - M // D = Memory[i] - Memory[R1] @END // ここでジャンプ先ラベルを指定する (実行コードの特定の行数を指す定数でもよい) D;JGT // if D &amp;gt; 0, jump to END @R0 D = M // D = Memory[R0] @R2 M = D + M // Memory[R2] += D (Memory[R0]) @i M = M + 1 // Memory[i] = Memory[i] + 1 @LOOP 0;JMP(END) @END 0;JMP 次の課題は、まずスクリーンの全面を黒く描画したうえで、押されていない場合では真っ白に塗りつぶすというものである。スクリーンのピクセルは 512 x 256 であり、ワードが 16 bit であることを踏まえるとここでは $(512/16) \\times 256 = 8192$ ワードが存在することになる。これに対して順番にループを回し画面の描画を行っていく。 このとき、1 ワード全体を塗りつぶすには当該レジスタに 1111111111111111 を代入する必要があるので注意。1 を代入すると最も左のピクセルのみ塗りつぶされることになってしまう。上記を符号付き 2 進数とみなすと 10 進数では -1 となるので、M = -1 とすれば OK。(LOOP) @24576 // 押されているキーの ASCII コードが現れる場所 // 何も押されていない場合は 0 が現れる D = M // D = Memory[24576] @WHITE // キーが押されている場合は (WHITE) に移動 D;JGT // if D &amp;gt; 0, jump to WHITE(BLACK) @i M = 0 // Memory[i] = 0(BLACKLOOP) @i D = M // D = Memory[i] @8191 D = D - A // D = D - 8191 @BLACKEND D;JGT // if D &amp;gt; 0, jump to END @i D = M // D = Memory[i] @SCREEN A = A + D // D = SCREEN + Memory[i] M = -1 // paint to black @i M = M + 1 // Memory[i] += 1 @BLACKLOOP 0;JMP(BLACKEND) @LOOP 0;JMP // 無限ループ(WHITE) @j M = 0(WHITELOOP) @j D = M // D = Memory[j] @8191 D = D - A // D = D - 8191 @WHITEEND D;JGT // if D &amp;gt; 0, jump to END @j D = M // D = Memory[j] @SCREEN A = A + D // A = SCREEN + Memory[j] M = 0 // paint to white @j M = M + 1 // j = j + 1 @WHITELOOP 0;JMP(WHITEEND) @LOOP 0;JMP" }, { "title": "コンピュータシステムの理論と実装 (3)", "url": "/posts/nand2tetris-03.html", "categories": "Technology, Low-Level", "tags": "Low-Level, HDL, nand2tetris, Book Review", "date": "2022-01-02 00:00:00 +0900", "snippet": "3 章 順序回路 今回は前章まで作成した「組み合わせ回路」と違って「順序回路」を作っていく。フリップフロップ (1 ビットの入力とクロック入力を受け取り、前のタイムポイントでの入力を出力する) は所与のものとして扱う。 まずは 1 bit レジスタを作成する。1 ビットの入力と load ビットを受け取り、load ビットが 1 の場合値を更新、0 の場合入力は無視される。これもマルチプレキサの a に何を代入したらよいのか分からなくて困ったが、例によって 賢そうな人の解答例 を見て、フィードバック入力を取れることを知った。CHIP Bit { IN in, load; OUT out; PARTS: Mux(a=fb, b=in, sel=load, out=out1); DFF(in=out1, out=out, out=fb);} お次は 16 bit レジスタだが、これは 1 bit レジスタを 16 個並べればよいだけなので簡単。load は 16 ビットではなく 1 ビットなので注意。 続いていよいよメモリを作っていく。RAM は先ほどまでにレジスタに渡していた in、load に加え、アドレス入力を受け取りさらに直接アクセスできる必要がある。8 レジスタメモリを作成する場合、まずデマルチプレキサを用いて各レジスタの load ビットを決定し、最後にマルチプレキサを用いてアクセスのあったレジスタの出力を返すようにすればよい。CHIP RAM8 { IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address, a=is0, b=is1, c=is2, d=is3, e=is4, f=is5, g=is6, h=is7); Register(in=in, load=is0, out=out0); Register(in=in, load=is1, out=out1); Register(in=in, load=is2, out=out2); Register(in=in, load=is3, out=out3); Register(in=in, load=is4, out=out4); Register(in=in, load=is5, out=out5); Register(in=in, load=is6, out=out6); Register(in=in, load=is7, out=out7); Mux8Way16(a=out0, b=out1, c=out2, d=out3, e=out4, f=out5, g=out6, h=out7, sel=address, out=out);} RAM64 を作る場合は同様に RAM8 を 8 つ並べることになる。address[0..2] の 3 bit でどの RAM8 かを指定し、残り address[3..5] の 3 bit を各 RAM8 に与える形にすればよい。RAM のサイズがもっと大きくなっても同様の方針でいける。 最後に作るのは 16 bit カウンタである。ここでは実行している命令コードの行数を格納するものを指しており、通常は単に前のタイムポイントでの入力をインクリメントすればよいので out(t + 1) = out(t) + 1 となる。ここでは、命令コードにジャンプ機能がついている場合も考え、出力を 0 にする reset ビットや load ビットも受け取れるようにしている。CHIP PC { IN in[16], load, inc, reset; OUT out[16]; PARTS: Inc16(in=fb, out=outinc); // out[t + 1] = out[t] + 1 Mux16(a=fb, b=outinc, sel=inc, out=out1); // inc なら outinc が返る Mux16(a=out1, b=in, sel=load, out=out2); // load なら in が返る Mux16(a=out2, b=false, sel=reset, out=out3); // reset なら zero が返る // ここまで、いずれもあてはまらない場合 out3 には fb が格納されている Register(in=out3, load=true, out=out, out=fb);}" }, { "title": "コンピュータシステムの理論と実装 (2)", "url": "/posts/nand2tetris-02.html", "categories": "Technology, Low-Level", "tags": "Low-Level, HDL, nand2tetris, Book Review", "date": "2022-01-01 00:00:00 +0900", "snippet": "あけましておめでとうではあるが、特に新年感もなく粛々と復習を続けていく。今日は第 2 章、ブール算術から。2 章 ブール算術加算器 $n$ ビットの 2 進数加算をする場合を考える。2 つのビットの和を求める半加算器 (half adder) が必要なのはまあ当たり前である。足し算の筆算的に最下位ビットから計算していくことを考えると、2 つのビットと繰り上がり (キャリービット) を加算することになる。この 3 つのビット の和を求めるのが全加算器 (full adder) である。 半加算器を書いていく。真理値表を書いてぐっと睨めばわかるが、sum (筆算で下に書くやつ) は Xor(a, b)、carry (繰り上がり) は And(a, b) で簡単に書ける。 CHIP HalfAdder { IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry);} 全加算器を書いていく。HalfAdder を 2 つ組み合わせることで実現できる。CHIP FullAdder { IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, sum=sum1, carry=carry1); HalfAdder(a=sum1, b=c, sum=sum, carry=carry2); Or(a=carry1, b=carry2, out=carry);} 16bit の加算器 Add16.hdl は単に最下位ビット用の Half Adder を 1 つと Full adder を 15 個組み合わせればよいので省略。 最後に実装すべきはインクリメンタであり、こちらは単に 1 を足すだけなので Add16 を使えばよいだけだが、HDL で 1 を作る方法がよく分からずまあまあ苦労した。一周目では常に 16bit の 1 を出力する CHIP をわざわざ自作してどうにかしたようだが、賢そうな人の解答例 を見る限りこんな感じで書けるらしい。入力の左辺には多ビットパスのピンの一部分を指定できるのね。CHIP Inc16 { IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, b[1..15]=false, out=out);}算術論理演算機 初歩的な算術演算と論理演算のすべてをまとめて行うためのものを算術論理演算機 (Arithmetic Logical Unit; ALU) とよぶ。名前がかっこよすぎないか……？ 16 ビット入力 $x$ と $y$、および 6 つの制御ビットを与えると 16 ビットの出力が返ってくるように実装する。基本的には p35 のフローにしたがって素直にやっていけすればよい。途中マルチプレキサを使う場面があるが、条件分岐の前にあらかじめありうる出力をすべて書き出して変数に格納しておくのがポイントっぽい。CHIP ALU { IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp;amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &amp;lt; 0), 0 otherwise PARTS: // if zx then x = 0 Mux16(a=x, b=false, sel=zx, out=x1); // b = false と簡潔に書ける // if nx then x = !x Not16(in=x1, out=notx1); Mux16(a=x1, b=notx1, sel=nx, out=x2); // if ny then y = 0 Mux16(a=y, b=false, sel=zy, out=y1); // if ny then y = !y Not16(in=y1, out=noty1); Mux16(a=y1, b=noty1, sel=ny, out=y2); // if f then out = x + y else out = x &amp;amp; y And16(a=x2, b=y2, out=andxy); // ありうる出力を先に全部書き出しておくのがポイント Add16(a=x2, b=y2, out=addxy); Mux16(a=andxy, b=addxy, sel=f, out=out1); // if no then out = !out Not16(in=out1, out=notout1); // 反転したものを準備 // ここで最終的な out が出力されるので、 // if out &amp;lt; 0 then ng = 1 else ng = 0 もついでに済ませてしまう Mux16(a=out1, b=notout1, sel=no, out=out, out=out2, out[15]=ng); // if out == 0 then zr = 1 else zr = 0 IsZero(in=out2, out=iszero); Mux(a=false, b=true, sel=iszero, out=zr);} 最後 out が 16bit の 0 かどうか判定する場面で、自分の書いたコードでは 16bit すべてについて Or を書いていく CHIP IsZero を書いていたのだけど、よく考えたら Or8Way を 2 回使えば済む話だった。 出力の際に OUT で定義されている同じ名前のピンを複数同時に書くことができることを知らなかったので難儀した。例えば out=out, out=out2, out[15]=ng のように out を複数存在させることができ、ここでちゃっかり新しい変数定義をしたり、出力ピン (の一部) を変数に代入できたりするらしい。逆に例えば in=out[15] のようにすると怒られが発生するので助けてくれーという気持ちに。" }, { "title": "コンピュータシステムの理論と実装 (1)", "url": "/posts/nand2tetris-01.html", "categories": "Technology, Low-Level", "tags": "Low-Level, HDL, nand2tetris, Book Review", "date": "2021-12-31 00:00:00 +0900", "snippet": "年末年始を利用して、2 年くらい前に買ったこの本を読んでいく。 コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方 | Noam Nisan, Shimon Schocken, 斎藤 康毅 |本 | 通販 | Amazon NAND ゲートのみが与えられた状態で、論理回路、加算器、ALU、CPU などを自作しつつ最終的にはテトリスが動く OS が出来上がるという触れ込みの本書。本文には実装の指針が示してあるのみでありコーディングは自力で頑張らなくてはいけないので普通に勉強になる一冊。まとまった時間ができた際に進めては中断し、その間に前やったことをすべて忘れるという一連の流れを 3, 4 回繰り返しており非常によろしくないのでいい加減終わらせたいところ。今回はまず第 1 章の復習をしつつまとめを作っていく。1 章 ブール論理NAND ゲート $\\overline{x \\cdot y}$ をもとに各種のプリミティブなゲートを作成していく。基本論理ゲート まずは Not から。これは Nand($x, x$) = $\\overline{x}$ であることからすぐに書ける。CHIP Not { IN in; OUT out; PARTS: Nand(a=in, b=in, out=out);} And もただ NAND を否定するだけでよい (NAND は AND の否定なので)。CHIP And { IN a, b; OUT out; PARTS: Nand(a=a, b=b, out=out1); Not(in=out1, out=out);} お次は Or の実装。一見ややこしいが、$\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$ (ド・モルガンの法則だっけ) を考えると Not(And(Not($x$), Not($y$))) であることが分かる。下記コードでは最後に And と Not を用いているが、せっかく Nand ゲートが用意されているのでこちらを使ってもよい。CHIP Or { IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=nota, b=notb, out=out1); Not(in=out1, out=out);} Xor (2 入力が異なる場合は 1 を、それ以外は 0 を返す) の実装。And と Or は実装済みなので正準表現を使ってしまうのが分かりやすい。真理値表により、Xor($x, y$) $= \\overline{x}y + x\\overline{y}$ であることが分かるのでコードは下記のようになる。CHIP Xor { IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=a, b=notb, out=out1); And(a=nota, b=b, out=out2); Or(a=out1, b=out2, out=out);} マルチプレキサ (セレクタが 0 のときは a を、1 のときは b を出力) の実装。if 文みたいなものだが、このあたりから話がややこしくなってくる。CHIP Mux { IN a, b, sel; OUT out; PARTS: Not(in=sel, out=notsel); // 例えば、sel = 0 のとき (a が選ばれるとき) Or(a=a, b=sel, out=aout); // aout = a となる Or(a=b, b=notsel, out=bout); // notsel = 1 なので bout = 1 となり下の And 式の結果に影響しない And(a=aout, b=bout, out=out); // 結果的に aout = a の値が出てくる} デマルチプレキサ (セレクタが 0 なら a の方に入力値を流す、1 なら b の方に入力値を流す) の実装。要はマルチプレキサの逆である。CHIP DMux { IN in, sel; OUT a, b; PARTS: Not(in=sel, out=notsel); And(a=in, b=notsel, out=a); // a は in と not(sel) との And And(a=in, b=sel, out=b); // b は in と sel との And}多ビットの基本ゲート本書で作るのは 16bit の OS なので、上で作った基本ゲートを 16bit に拡張していく。例えば Not16.hdl は以下のようになる。1bit 版のものを 16 個羅列すればいいだけなので特に難しいところはない (タイピングは面倒だが)。多ビットマルチ/デマルチプレキサも選択は 1bit で行うので注意。CHIP Not16 { IN in[16]; OUT out[16]; PARTS: Not(in=in[0], out=out[0]); Not(in=in[1], out=out[1]); Not(in=in[2], out=out[2]); Not(in=in[3], out=out[3]); Not(in=in[4], out=out[4]); Not(in=in[5], out=out[5]); Not(in=in[6], out=out[6]); Not(in=in[7], out=out[7]); Not(in=in[8], out=out[8]); Not(in=in[9], out=out[9]); Not(in=in[10], out=out[10]); Not(in=in[11], out=out[11]); Not(in=in[12], out=out[12]); Not(in=in[13], out=out[13]); Not(in=in[14], out=out[14]); Not(in=in[15], out=out[15]);}多入力の基本ゲート 2 入力の基本ゲートを一般化する。例えば $n$ 入力 Or ゲートの場合、入力 $n$ ビットのうち少なくとも少なくとも一つが 1 であれば 1 を出力する形になる。CHIP Or8Way { IN in[8]; OUT out; PARTS: Or(a=in[0], b=in[1], out=out1); Or(a=out1, b=in[2], out=out2); Or(a=out2, b=in[3], out=out3); Or(a=out3, b=in[4], out=out4); Or(a=out4, b=in[5], out=out5); Or(a=out5, b=in[6], out=out6); Or(a=out6, b=in[7], out=out);} 次に $m$ 入力のマルチプレキサを考えると、$m$ 個の入力中から 1 個を選択して出力する形になるので選択ビットは $k = \\log{m}$ となる。例えば $m = 4$ の場合 $k = 2$ である。実装はマルチプレキサを 2 つ組み合わせればよく、sel[0] を用いて a vs b と c vs d でトーナメント 1 回戦を行ったのち、sel[1] で 2 回戦をやるイメージでいける。CHIP Mux4Way { IN a, b, c, d, sel[2]; OUT out; PARTS: Mux(a=a, b=b, sel=sel[0], out=aorb); Mux(a=c, b=d, sel=sel[0], out=cord); Mux(a=aorb, b=cord, sel=sel[1], out=out);} 最後に $m$ 出力のデマルチプレキサを考える。入力を $m$ 個の出力先に振り分けることになるので、選択ビットは上記同様 $k = \\log{m}$ である。CHIP DMux4Way { IN in, sel[2]; OUT a, b, c, d; PARTS: // まず、a, b と c, d のどちらかであるかを決めてしまう DMux(in=in, sel=sel[1], a=w1, b=w2); // sel[1] = 0 なら w1 = in、sel[1] = 1 なら w1 = 0 // 以下で、sel[1] = 0 なら w1 = in が正しく a か b かどちらかに振り分けられるし、 // sel[1] = 1 なら、そもそも w1 = 0 なので a も b も 0 になるという仕組み DMux(in=w1, sel=sel[0], a=a, b=b); DMux(in=w2, sel=sel[0], a=c, b=d);}検証本書の良いところは、公式サイト にあるツールを用いれば書いたコードの検証ができるところである。今回のコードは Hardware Simulator というソフトウェアの Load Script から .tst ファイルを取り込めば一通りのテストが実行できる。テストをすべて pass するとこんな感じでステータスバーにその旨が表示されるので、競プロで AC した感じがして楽しい。やったね！" }, { "title": "IoT を使って嫌でも風呂に入らざるを得ないようにする", "url": "/posts/take-a-bath.html", "categories": "Technology, IoT", "tags": "Python, IoT, Product", "date": "2021-12-28 00:00:00 +0900", "snippet": "概要今に始まったことではないが、入浴というものが基本的にあまり好きではない (入浴より重要でかつ楽しいことはたくさんあるので)。現代を生きている人間である以上回避不可能なイベントなのでしゃーなし毎朝シャワーを浴びてはいるものの、億劫すぎて毎日ギリギリまで入浴を引き延ばした挙句髪のセットがおろそかになり、結果的に崩壊したヘアスタイルでの出勤を余儀なくされている。今回はこのような状況を打破すべく、毎朝決まった時間にシャワーを浴びることに対して何らかの動機付けをするシステム構築に取り組むことにした。動機付けの方法はいろいろ考えられるが、今回は「シャワーを浴びないとすごく嫌なことが発生する」形式を採用することにした。具体的には「朝 6 時に風呂場の湿度が一定以上になっていないと、寝室の照明が数秒おきに点滅を繰り返す」という非常に迷惑な仕組みを以下で実現していく。実装の概略は以下の通り。 浴室に設置しておいた SwitchBot 温湿度計から、Bluetooth を介して Raspberry Pi で値を取得する 浴室の湿度が一定の値以下である場合、Raspberry Pi から Nature Remo の Local API を叩き、寝室の照明のスイッチを切り替える 1, 2 を朝 6 時に開始したうえで数秒おきに繰り返し、浴室の温度が一定の値以上になったところでプログラムを終了させる事前準備用意するもの今回は以下の製品を購入した。湿度計付きの Remo3 を買っておけば SwitchBot は不要だったのではないかという気はするが、浴室に Remo を設置すると部屋の家電に赤外線が届かないのでこのような構成を採ることになった。 Raspberry Pi3 Model B+ with Python 3.10 Nature Remo mini2 SwitchBot 温湿度計湿度の閾値を決定する浴室に SwitchBot 温湿度計を設置し、試しにシャワーを浴びてみたところ以下のようになった。この日は朝 8 時ごろに入浴しており、ちょうどその時間帯に湿度が著明に上昇していることが分かる。今の季節はベースの湿度が低めなので今後もう少し閾値を上げる必要があるかもしれないが、とりあえずは 50% 程度に設定しておけばよさそうだ。実装SwitchBot 温湿度計から湿度を取得する特に何もしなくても上記のように湿度を確認することはできるが、これはアプリを手動で開くたびに湿度計と iPhone が Bluetooth を介して通信し今までのログをまとめて受信するという形式であり、今回の用途には向かない。リアルタイムでの自動的な計測値取得には二通りの方法が考えられる。 SwitchBot Hub Mini を購入し、cloud-based API を叩く Raspberry Pi と BLE (Bluetooth Low Energy) で接続して値を取得する今回は、API に Rate Limit (10000 requests/day, 9 秒に一回程度しか実行できない) が存在するということを踏まえて後者の方法を採用した。まず、BLE 通信の下準備として Raspberry Pi にパッケージ bluepy のインストールを行う。pip install bluepyこのライブラリを用いて、SwitchBot 温湿度計からの BLE Advertisement パケットを受け取り値を取得する方針とする。BLE を用いて通信するには SwitchBot 側の BLE MAC アドレスが必要であるが、こちらは SwitchBot アプリのデバイス情報から確認できる。下記コードは こちらの記事 を参考にさせていただいた。これを実行すると、約 2 秒おきに湿度データが取得できる。import binasciifrom bluepy.btle import Scanner, DefaultDelegateclass ScanDelegate(DefaultDelegate): def __init__(self) -&amp;gt; None: self.MAC_ADDRESS: str = &#39;xx:xx:xx:xx:xx:xx&#39; # lower case DefaultDelegate.__init__(self) def handleDiscovery(self, dev, isNewDev, isNewData) -&amp;gt; None: if dev.addr == self.MAC_ADDRESS: for (adtype, desc, value) in dev.getScanData(): if (adtype == 22): servicedata: bytes = binascii.unhexlify(value[4:]) humidity: int = servicedata[5] &amp;amp; 0b01111111 print(&#39;humidity: &#39; + str(humidity))if __name__ == &#39;__main__&#39;: scanner = Scanner().withDelegate(ScanDelegate()) scanner.scan(0)部屋の照明を点滅させる事前準備として、部屋の照明を Nature Remo に登録しておく。照明を操作するには Nature Could API を利用することもできるが、こちらも Rate Limit (30 requests/5 min, 10 秒に一回程度) が存在する。照明の点滅が 10 秒おきでは嫌がらせとして少々迫力に欠けるので、今回はサーバを介さずに Local API の方を使うことにした。使用方法については こちらの記事 を参考にさせていただいた。リクエストの送信先を指定Local API の利用には Nature Remo のプライベート IP アドレスが必要であるため、ルータの管理画面 (Baffalo の場合は こちら) から調べる必要がある。ついでにプライベート IP の固定もしてしまおう。Local API で Nature Remo と通信直前にリモコンを用いて Remo に向けて当該信号を送っておき、curl http://&amp;lt;private IP&amp;gt;/messages -H &quot;X-Requested-With: local&quot;と叩くと JSON が返ってくる。赤外線信号を送信するには、返ってきたものをそのまま POST すればよい。class Light(): def __init__(self) -&amp;gt; None: self.headers: dict = { &#39;X-Requested-With&#39;: &#39;local&#39;, } self.data: str = &#39;{&quot;format&quot;:&quot;us&quot;,&quot;freq&quot;:38,&quot;data&quot;:[3397, ...]}&#39; def switch(self) -&amp;gt; None: requests.post(&#39;http://&amp;lt;private IP&amp;gt;/messages&#39;, headers=self.headers, data=self.data)定時実行あとはこれを毎朝 6 時に実行させればよいだけである。BLE の scan には sudo 権限が必要であるため、crontab -e で以下を登録しておく。PATH=/home/pi/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin0 6 * * * sudo /usr/local/bin/python3.10 $HOME/take-a-bath.py最終的なコードは以下の通り。import datetimeimport requestsimport binasciifrom bluepy.btle import Scanner, DefaultDelegateimport sysclass Light(): def __init__(self) -&amp;gt; None: self.headers: dict = { &#39;X-Requested-With&#39;: &#39;local&#39;, } self.data: str = &#39;{&quot;format&quot;:&quot;us&quot;,&quot;freq&quot;:38,&quot;data&quot;:[3397, ...]}&#39; def switch(self) -&amp;gt; None: requests.post(&#39;http://&amp;lt;private IP&amp;gt;/messages&#39;, headers=self.headers, data=self.data)class ScanDelegate(DefaultDelegate): def __init__(self) -&amp;gt; None: self.MAC_ADDRESS: str = &#39;xx:xx:xx:xx:xx:xx&#39; # lower case self.light = Light() DefaultDelegate.__init__(self) def handleDiscovery(self, dev, isNewDev, isNewData) -&amp;gt; None: if dev.addr == self.MAC_ADDRESS: for (adtype, desc, value) in dev.getScanData(): if (adtype == 22): servicedata: bytes = binascii.unhexlify(value[4:]) humidity: int = servicedata[5] &amp;amp; 0b01111111 print(datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;), str(humidity)) if humidity &amp;lt; 50: self.light.switch() else: sys.exit()if __name__ == &#39;__main__&#39;: scanner = Scanner().withDelegate(ScanDelegate()) scanner.scan(0)感想実際にこの嫌がらせの被害に遭ってみると、特に冬場まだ陽が出ていない時間帯は明暗の差が激しいので特にきついということを身をもって体感した。とりあえず寝室 (ワンルームなので実質浴室と居間しかないのだが) から逃げ出したくなるので、朝とりあえず目覚めたはいいものの布団から出られずベッドでだらだらスマホをいじってしまうといった事態の防止にもなり一石二鳥であった。今後暇があったら以下の機能も追加したい。 夜間勤務の影響で朝 6 時に不在の場合への対応 (あまりないだろうが) 朝 5 時ごろに入浴を済ませてしまい、6 時にはすでに湿度が低下していた場合の対策" }, { "title": "「麻酔科研修 30 日ドリル」を読んだ", "url": "/posts/anesthesiology-checknote.html", "categories": "Medicine, Anesthesiology", "tags": "Book Review", "date": "2021-12-11 00:00:00 +0900", "snippet": "麻酔科研修が終わってからなので完全にやる気を失っているが、標記の本を読んだ (というかこなした) ので簡単にまとめておく。 100倍楽しくなる麻酔科研修30日ドリル | 青山 和義, 讃岐 美智義 |本 | 通販 | Amazon 概要 購入動機：麻酔科研修開始前に本書の姉妹本「麻酔科研修チェックノート」を読んだ (読もうとした) のだが、書いてあることの意味はだいたい理解できるものの何がポイントなのか分からなかったため購入。基本的に何か書き込みながらでしか読書に集中することができず、いっそ潔くドリル形式のものの方が自分に合っていそうと考えた。 かかった時間：休日丸一日と平日の退勤後何日間かを使って終わらせた。ものすごく気合を入れてがんばれば 2 日くらいで完了する人もいそう。雑感 麻酔科研修に直接役立つのはもちろんのこと、特に「術前内服薬、絶飲食」の章にある「主な抗血栓薬と中止目安」「ARB および ACE 阻害薬」の表は病棟管理でも重宝しそう。 単に計算問題がまあまああるのも手伝って、めちゃくちゃ夏休みの宿題をやっている気分になった。穴埋め式の問題集をやるのなんて何年ぶりか。 やはり物理的に手を動かすとなんとなく「やってる感」も出るし、すべての空欄を埋め終えたときの達成感はひとしお。他の分野でもこういう受験勉強風ドリルを発売してほしい。" }, { "title": "Amazon Prime Video の Watch Party でチャット履歴を保存する", "url": "/posts/watch-party.html", "categories": "Technology, Automation", "tags": "JavaScript, Product", "date": "2021-12-08 00:00:00 +0900", "snippet": "動機最近 Amazon Prime Video で動画を複数人で同時視聴できるサービス (Watch Party) を使い始めた。再生しながら視聴者どうしでチャットができるという便利なものなのだが、ホストが Watch Party を終了させるとチャット履歴が消失するという問題がある。そこで、Watch Party のページをスクレイピングすることによりチャット履歴を記録したテキストファイルをダウンロードするスクリプトを書いた。実装 めちゃくちゃ意識が低くてアレだが、Watch Party にあるチャットウィンドウの要素を漁り、innerText からチマチマ情報を抽出していく (下記コードの create_chat_text() 部分)。これを text/plain の blob として作成したうえで、ダウンロードリンクをページに追加する。以上の作業を Tampermonkey の UserScript で行う。 ブラウザで Watch Party のリンクにアクセスした場合、まず参加設定 (チャットに用いるハンドルネームなど) に飛ばされ、入力後に再生画面およびチャットウィンドウが表示される仕様になっている (URL の変更はなし)。つまりアクセス直後はチャットウィンドウがまだ表示されていないため、要素を取得するためにはユーザが設定を終えて再生画面に遷移するのを待つ必要がある。これを実現するため、チャットウィンドウの要素が表示されるまで 1 秒おきに要素の取得を繰り返すという脳筋仕様にしてしまった (下記コードの wait_load() 部分)。絶対もっとマシな書き方があるはずなので、暇なときに改訂したい。// ==UserScript==// @name Watch Party// @namespace http://tampermonkey.net/// @version 0.1// @description Add button to download chat histories in Amazon Prime Watch Party// @author You// @match https://www.amazon.co.jp/gp/video/watchparty/*// @grant none// ==/UserScript==(function() { &#39;use strict&#39;; window.dl = function() { var blob = update_blob(); var newA = document.getElementById(&quot;download_link&quot;); newA.href = window.URL.createObjectURL(blob); } wait_load();})();var get_footer = function () { var footer = document.evaluate( &#39;//*[@id=&quot;embeddedChat&quot;]/div/div/div/div/div/div/div/div[3]&#39;, document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null ); return footer;};function create_chat_text() { var chat_text = &quot;&quot;; var chats_elems = document.evaluate( &#39;//*[@id=&quot;embeddedChat&quot;]/div/div/div/div/div/div/div/div[2]/div/div&#39;, document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null ); var this_elem = chats_elems.iterateNext(); Array.prototype.forEach.call(this_elem.children, function (elem) { var inner_text = elem.innerText; var splitted; if (elem.getAttribute(&quot;data-testid&quot;) === &quot;MessageClusterIncoming&quot;) { splitted = inner_text.split(&quot;\\n&quot;); if (splitted[3] != null) { for (var i = 3; i &amp;lt; splitted.length; i++) { chat_text += `${splitted[2]}\\t${splitted[0]}\\t${splitted[i]}\\n`; } } else { chat_text += `${splitted[2]}\\t${splitted[0]}\\tStamp\\n`; } } else if (elem.getAttribute(&quot;data-testid&quot;) === &quot;MessageClusterOutgoing&quot;) { splitted = inner_text.split(&quot;\\n&quot;); if (splitted[1] != null) { var time = splitted[splitted.length - 1]; for (var i = 0; i &amp;lt; splitted.length - 1; i++) { chat_text += `${time}\\tMe\\t${splitted[i]}\\n`; } } else { chat_text += `${inner_text}\\tMe\\tStamp\\n`; } } else { chat_text += inner_text === &quot;&quot; ? &quot;&quot; : `--- ${inner_text} ---\\n`; } }); return chat_text;}function update_blob() { var header_text = `Exported at ${new Date()}\\n\\n`; var chat_text = create_chat_text(); var blob = new Blob([header_text + chat_text], { type: &quot;text/plain&quot; }); return blob;}function init() { var footer = get_footer(); var this_elem = footer.iterateNext(); var stamp = this_elem.firstChild; var newA = document.createElement(&quot;a&quot;); newA.id = &quot;download_link&quot;; newA.innerHTML = &quot;Download Chat History&quot;; newA.style.color = &#39;rgb(242, 244, 246)&#39;; newA.setAttribute(&quot;onclick&quot;, &quot;dl()&quot;); newA.download = &#39;&#39;; stamp.after(newA);}function wait_load() { var fn = function () { var footer = get_footer(); if (footer.iterateNext() != null) { console.log(&#39;found&#39;); clearInterval(id); init(); } else { console.log(&quot;not found&quot;); } }; var id = setInterval(fn, 1000);}できたものこれを Tampermonkey に追加すると以下のようになる。チャットウィンドウに表示された Download Chat History をクリックすると、以下のテキストファイルがダウンロードされる。Exported at Wed Dec 08 2021 17:10:40 GMT+0900 (日本標準時)--- ビデオを一時停止しています ------ hoge参加 ------ hogeが再生をコントロールします ---19 分 hoge Hello!--- hogeが退出しました ------ fuga参加 ------ fugaが再生をコントロールします ---19 分 Me Hello!19 分 Me How are you?今後やりたいこと ダウンロードボタンが追加されるのが気に入らないので、Tampermonkey ではなく Chrome 拡張機能として導入し、拡張機能のアイコンをクリックでダウンロードできるようにしたい 動画のタイトルを自動で取得しテキストファイルのファイル名に設定するようにしたい。動画再生中なら h1 h2 タグ抽出により取得できるのだが、終了後には要素ごと消えてしまう模様。何らかの方法で動画のメタデータを入手できればよいのだけど……" }, { "title": "低 Na 血症", "url": "/posts/hyponatremia.html", "categories": "Medicine, Electrolytes", "tags": "", "date": "2021-08-09 00:00:00 +0900", "snippet": "症状 軽症 (130-135) 中等症 (125-129): 悪心・混乱・頭痛 重症 (&amp;lt; 125): 嘔吐・心/呼吸器症状、痙攣、昏睡・昏迷補正 Na の計算蛋白・脂質高値のとき (偽性低 Na 血症) 補正後の値が基準範囲内であれば治療は必要ない。式を見れば分かるように、相当高くなっていなければ低 Na にはならないが…… 血ガスではこれらの影響を受けないので注意。\\[\\mbox{補正 Na} = \\mbox{Na} + \\frac{\\mbox{TG} - 100}{460} \\\\\\mbox{補正 Na} = \\mbox{Na} + 1.2 \\times (\\mbox{TP} - 7)\\]高血糖のとき (高浸透圧性低 Na 血症) 補正後の値が基準範囲内であれば治療は必要ない (高血糖の方をなんとかすべき)。 水が間質・血管に移動し、細胞は小さくなっている。グリセロール、マンニトールなど脳浮腫の治療でも同じことが起こるのは納得がいく。\\[\\mbox{補正 Na} = \\mbox{Na} + 2 \\times \\frac{\\mbox{Glu} - 100}{100}\\]診断 尿浸透圧が 100mOsm/kg であれば水中毒を疑う 尿浸透圧は、尿浸透圧の下二桁 x 20-40 で計算できる (1.015 なら 300-600 mOsm/kg) FENa の計算\\[\\mbox{FENa} = \\frac{\\mbox{尿中 Na} \\times \\mbox{血清 Cr}}{\\mbox{血清 Na} \\times \\mbox{尿中 Cr}} \\times 100\\]FENa &amp;gt; 1% の場合は Na 排泄が亢進しているため、腎性を疑う。治療 急性の低 Na では 8mEq/L/day (0.33mEq/L/hr) 以下、慢性ではさらに緩徐に補正を行う。 Na &amp;lt; 125 未満でありかつ意識障害・痙攣・嘔吐などの重篤な症状がある場合は 3% 食塩水の適応となる。輸液ポンプを用いて 30mL/hr で開始し、1hr ごとに採血し 5mEq/L 程度上昇したら (およそ数時間) その後 24hr 補正を中止する。 上記の適応外の場合は生食か水制限による治療を行う。補正速度の計算 輸液 1L 投与による血清 Na 上昇の予測式\\[\\mbox{血清 Na 上昇 [mEq/L]} = \\frac{\\mbox{輸液中 (Na + K)} - \\mbox{血清 Na}}{\\mbox{体重} \\times 0.6 + 1}\\] 何もしなかった場合の 1h 後の血清 Na 上昇を尿所見で予測\\[\\mbox{血清 Na 上昇[mEq/L/hr]} = \\frac{\\mbox{血清 Na} \\times 体重 \\times 0.6 - \\mbox{(尿中 Na + K)} \\times \\mbox{尿量}}{\\mbox{体重} \\times 0.6 - \\mbox{尿量}} - \\mbox{血清 Na}\\] 計算フォーム (Na 8mEq/L/day 上昇を目指す場合)必須血清 Na　mEq必須投与輸液3 % 食塩水生理食塩水乳酸リンゲル必須体重　kg尿量　L尿中 Na　mEq/L尿中 K　mEq/L参考文献 レジデントのためのこれだけ輸液, 佐藤弘明, 日本医事新報社, 2020" }, { "title": "高 Na 血症", "url": "/posts/hypernatremia.html", "categories": "Medicine, Electrolytes", "tags": "", "date": "2021-08-09 00:00:00 +0900", "snippet": "症状 軽症: 無気力・いらいら感 重症: 見当識障害・痙攣・昏睡 (Na &amp;gt; 150 で症状が出やすい)治療 無症状で軽度なら飲水励行でよい 血管内脱水がありそう (低血圧、頻脈、腋窩・口腔内乾燥、ツルゴール低下) なときは外液投与。250mL/hr くらい？ 血管内脱水がない or 落ち着いたときは、5% ブドウ糖液を投与。速度は下記参照 高 Na 血症では通常水が血管側に抜けて細胞は小さくなっているが、慢性の場合は細胞の大きさがある程度回復している場合も多い。なので、特に慢性の場合に急速に補正するのは脳浮腫のリスクを上げる5% ブドウ糖液の投与速度計算 水分欠乏量 $W$ [L] $=$ 体重 [kg] $\\times 0.6 \\times \\frac{Na - 140}{140}$ 補正速度は 急性 (48 時間以内) なら 12mEq/L/day (0.50mEq/L) 慢性 (48 時間以上) なら 8mEq/L/day (0.33mEq/L) 発症時期不明の場合は慢性として考える。この場合、$T = \\frac{Na - 140}{0.33}$ 時間かける。 1 時間あたりの投与速度は $\\frac{W}{T}$ [L/hr] となる。 これに、 1 日に必要な水分量 (1500mL, いつも 3 本回ししているノリで) = 62.5mL/hr を加える。投与速度計算用フォーム必須経過慢性急性必須体重　kg必須不感蒸泄分　mL必須血清 Na　mEq参考文献 レジデントのためのこれだけ輸液, 佐藤弘明, 日本医事新報社, 2020" }, { "title": "酸塩基平衡障害の鑑別", "url": "/posts/gas-diagnosis.html", "categories": "Medicine, Electrolytes", "tags": "", "date": "2021-08-09 00:00:00 +0900", "snippet": "鑑別の手順実装は こちら Step1: アシデミア or アルカレミア？ Step2: 呼吸性 or 代謝性？ Step3: 代償は適切か 代償の式はかなりややこしい 代謝性の場合は PaCO2 = HCO3- + 15 となっているかどうかで代償が適切か判断できる？ Step4: AG と補正 HCO3- を計算 AG が開大していれば AG 開大性代謝性アシドーシスがあることは確定 pH が正常範囲内でも、補正 HCO3- (HCO3- + 14 - AG) &amp;gt; 26 なら代謝性アルカローシスが隠れている Step5: 鑑別を考える鑑別疾患代謝性アシドーシスAG 非開大性 (高 Cl 性)HARD-UP のゴロ合わせで覚える。現実的に最も考えやすいのは下痢と尿酸性化障害 (RTA, 腎不全初期)。 Hyperalimentation (過栄養) Acetazoramide (アセタゾラミド): 利尿薬は低 K かつアルカローシスをきたすが、アセタゾラミドは例外。人工的に RTA II 型を起こしているようなもの。 Addison’s disease (アジソン病) Renal tubular acidosis (尿細管性アシドーシス): 例外的に低 K かつアシドーシス Diarrhea (下痢): 例外的に低 K かつアシドーシス Ureteroenteric fistula (尿腸管瘻) Pancreatic fistula (膵液瘻)、parenteral saline (NaCl 大量補液)AG 開大性KUSSMAL-P のゴロ合わせで覚える。 Ketoasidosis (ケトアシドーシス) Uremia (尿毒症、腎不全) Salicylic acid (サリチル酸) Sepsis Methanol Alcoholic, Aspirin intoxication (アルコール中毒、アスピリン中毒) Lactic acidosis (乳酸アシドーシス。臓器虚血、けいれん発作後、VitB1 欠乏症に注意) Paraldehyde (パラアルデヒド)代謝性アルカローシスどこかから Cl が排出されている。では一体どこから？尿 Cl &amp;lt; 20mEq のとき嘔吐 (Cl が口から出ている)。生理食塩水で改善。尿 Cl &amp;gt; 20mEq のときABCD のゴロ合わせで覚える。尿から Cl が出ていってしまっている。 Aldosterone (アルドステロン症) Bartter / Gitelman (低 Mg 血症を合併するよね) Cushing Depletion of Magnesium呼吸性アシドーシス 急性: 上気道閉塞・喘息発作 慢性: COPD, 中心神経抑制、神経筋疾患;呼吸性アルカローシス 急性: 低酸素血症・発熱・敗血症・過換気・薬物 慢性: 貧血・妊娠・庵不全・脳血管障害参考文献 レジデントのためのこれだけ輸液, 佐藤弘明, 日本医事新報社, 2020 水・電解質と酸塩基平衡, 黒川清, 南江堂, 2004" }, { "title": "血液ガスの判定", "url": "/posts/gas.html", "categories": "Medicine, Electrolytes", "tags": "JavaScript, Tools", "date": "2021-08-08 00:00:00 +0900", "snippet": "鑑別用フォーム理論は こちら必須経過急性慢性必須pH必須PaCO2　mmHg必須HCO3-　mEq/LNa+　mEq/LCl-　mEq/LAlb　g/dL実装 ToDo 現実的に考えにくい場合 (アシデミアなのに PaCO2 低値かつ HCO3- 高値、など) への対応 代謝性と呼吸性両方を合併している場合 (アシデミアの状態で PaCO2 高値かつ HCO3- 低値、など) への対応。結果は正しく出るので問題はないが、どちらをメインに据えるか参考文献 レジデントのためのこれだけ輸液, 佐藤弘明, 日本医事新報社, 2020 水・電解質と酸塩基平衡, 黒川清, 南江堂, 2004" }, { "title": "セフェム系", "url": "/posts/cephem.html", "categories": "Medicine, Infectious Diseases", "tags": "", "date": "2021-07-28 00:00:00 +0900", "snippet": " 基本的に 嫌気性菌 には効かない (CMZ のみ例外)。腸球菌にも効かない。 世代が上がるにつれて GNR のカバーが広がり、GPC のカバーが下がる。第 4 世代は 第 1 世代 + 第 3 世代。第一世代セフェムCEZ (セファゾリン = セファメジン) MSSA の第一選択。レンサ球菌もいける。髄液移行性はないので、MSSA 髄膜炎には使用できないので注意が必要。 蜂窩織炎、感受性のある E.coli による腎盂腎炎、術前投与など (嫌気性菌をカバーする必要がない場合など) 経口薬はセファレキシン = ケフレックス   グラム陽性 グラム陰性 球菌 ◎   桿菌   △ E.coli くらい 第二世代セフェム セフォチアム = パンスポリン：嫌気性菌のカバーなし (これいつ使うんだ？) セフメタゾール = セフメタゾン、フロモキセフ = フルマリンは嫌気性菌のカバーあり。セフェムでは例外！CMZ (セフメタゾール)セフェム系としては例外的に嫌気性菌に効く。ESBL 産生菌にも時々効く。消化管移行性ヨシ。   グラム陽性 グラム陰性 球菌 〇   桿菌   〇 嫌気性菌 第三世代セフェム セフトリアキソン・セフォタキシム：緑膿菌のカバーなし セフタジジム：緑膿菌のカバーあるが、そういう時は第 4 世代セフェムを使うのでイマイチ出番がないCTRX (セフトリアキソン = ロセフィン) セフォタキシムと同一スペクトラムだが、セフォタキシムが腎代謝であるのに対し CTRX は肝代謝なので腎機能を気にしなくてよい。 普通のセフェムは半減期が 1 時間だが、CTRX は 6 時間なので 1 日 1 回で済むのも利点。 市中肺炎の第一選択。髄液移行性良いので細菌性髄膜炎にも使える。尿路感染症もこれでよい。   グラム陽性 グラム陰性 球菌 △   桿菌   ◎ 第四世代セフェムCFPM (セフェピム = マキシピーム) 医療関連感染を想定するときに使える。FN のときなど。髄液移行性あり。   グラム陽性 グラム陰性 球菌 ◎   桿菌   ◎ 緑膿菌 参考文献 絶対わかる抗菌薬はじめの一歩, 矢野晴美, 羊土社, 2010" }, { "title": "ペニシリン系", "url": "/posts/penicillin.html", "categories": "Medicine, Infectious Diseases", "tags": "", "date": "2021-07-27 00:00:00 +0900", "snippet": "古典的ペニシリンPCG (ペニシリン G) 梅毒 (静注)・肺炎球菌 (ペニシリン感受性: PSSP) の第一選択 MSSA、淋菌は耐性菌出現により不可になってきている。   グラム陽性 グラム陰性 球菌 〇   桿菌     アミノペニシリン大腸菌など、一部の腸内細菌に対して効くようになった。ABPC (アンピシリン = ビクシリン) 経口薬は AMPC (アモキシシリン = サワシリン)。A 群溶結連鎖球菌による咽頭炎、中耳炎、副鼻腔炎、尿路感染などに使える。 腸球菌の第一選択。β ラクタマーゼを産生する GNR には無効。   グラム陽性 グラム陰性 球菌 ◎ 腸球菌 モラキセラ 桿菌 リステリア △ 大腸菌、インフル桿菌 (クレブシエラ不可) ABPC/SBT (アンピシリン・スルバクタム = スルバシリン) 経口薬はアモキシシリン・クラブラン酸 = オーグメンチン。小児には配合比の異なるクラバモックスがある。中耳炎等で重宝する。 β ラクタマーゼ阻害剤 (スルバクタム) を加えて嫌気性菌、MSSAに対応。   グラム陽性 グラム陰性 球菌 ◎   桿菌   ◎ 嫌気性菌 抗緑膿菌ペニシリンPIPC (ピペラシリン = ペントシリン) 単剤で使われることはほとんどない。   グラム陽性 グラム陰性 球菌 ◎   桿菌   △ 緑膿菌 PIPC/TAZ (ピペラシリン・タゾバクタム = ゾシン) β ラクタマーゼ阻害剤 (タゾバクタム) を加えて嫌気性菌、MSSAに対応。   グラム陽性 グラム陰性 球菌 ◎   桿菌   ◎ 嫌気性菌、緑膿菌 参考文献 絶対わかる抗菌薬はじめの一歩, 矢野晴美, 羊土社, 2010" }, { "title": "2021-07-27", "url": "/posts/carbapenem.html", "categories": "Medicine, Infectious Diseases", "tags": "", "date": "2021-07-27 00:00:00 +0900", "snippet": "カルバペネム系MEPM (メロペネム)   グラム陽性 グラム陰性 球菌 ◎   桿菌   ◎ 嫌気性菌、緑膿菌 " }, { "title": "抗菌薬の基本", "url": "/posts/antibiotics.html", "categories": "Medicine, Infectious Diseases", "tags": "", "date": "2021-07-26 00:00:00 +0900", "snippet": "細菌の分類   グラム陽性 グラム陰性 球菌 ＜GPC＞レンサ球菌黄ブ肺炎球菌腸球菌 ＜GNC＞淋菌髄膜炎菌モラキセラ・カタラーリス 桿菌 ＜GPR＞(くりようかん)クロストリジウムリステリアコリネバクテリウム ＜GNR＞緑膿菌腸内細菌 (大腸菌など/嫌気性菌)クレブシエラインフル桿菌 特定の細菌への対策 黄色ブドウ球菌 MSSA: セファゾリン MRSA: バンコマイシン 腸球菌 Enterococcus faecalis (主に市中感染): ABPC Enterococcus faecium (主に医療関連): VCM VRE (ABPC, VCM いずれにも耐性): リネゾリド (オキサゾリジン系) 緑膿菌 PIPC/TAZ, CFPM メロペネム (カルバペネム系) レボフロキサシンなどニューキノロン系 ゲンタマイシンなどアミノグリコシド系 嫌気性菌 (バクテロイデス、CD、アメ赤、ランブルなど。副鼻腔炎・扁桃炎/周囲膿瘍・縦郭炎・腹腔内感染・骨盤部内感染・膿瘍・瘻孔形成の場合に疑う) メトロニダゾール クリンダマイシン ABPC/SBT, PIPC/TAZ (β ラクタマーゼを加えた組) CMZ (セフェムのなかでは例外) その他: フロモキセム (第二世代セフェム)、カルバペネム系、モキシフロキサシン β ラクタマーゼ産生菌 (MSSA、グラム陰性菌、バクテロイデスなどの嫌気性菌) スルバクタム・クラブラン酸、タゾバクタム 参考文献 絶対わかる抗菌薬はじめの一歩, 矢野晴美, 羊土社, 2010" }, { "title": "胃薬の使い分け", "url": "/posts/stomach-medicine.html", "categories": "Medicine, Drugs", "tags": "", "date": "2021-07-25 00:00:00 +0900", "snippet": "消化薬・胃腸機能調整薬消化酵素薬膵臓性消化酵素配合薬、総合消化酵素薬など健胃薬・胃腸機能調整薬抗ドパミン薬：ジストニア、薬剤性パーキンソニズムに注意！ メトクロプラミド (プリンペラン) 内服：1 回 5-10 mg、6 時間以上空けて 静注：1 回 10mg/1A、6 時間以上空けて ドンペリドン (ナウゼリン) 内服：1 回 10 mg、7-8 時間空けて 座薬：1 回 60 mg、7-8 時間空けて 上記 2 つの薬剤の違いについて！ メトクロプラミド：注射薬があって使いやすいが、中枢移行しやすいのがデメリット ドンペリドン：座薬があり、中枢移行ほぼないのがメリット。妊婦には禁忌 消化性潰瘍治療薬攻撃因子抑制薬 制酸薬：炭酸水素ナトリウム・アルミニウム・マグネシウムなど 抗ペプシン薬：スクラルファート 抗コリン薬 (前立腺肥大・緑内障に注意！): ブスコパンなど 抗ガストリン薬：セクレチン・ガストロゼピン（あまり作用が強くない？) H2 ブロッカー：シメチジン (タガメット)、ファモチジン (ガスター) など PPI：オメプラゾール、ランソプラゾール (タケプロン)、ラベプラゾールナトリウム (パリエット)防御因子賦活薬 粘膜の被覆 粘膜血流 プロスタグランジン系：レバミピド (ムコスタ) など参考文献 頻用薬の選び方・使い方, 「臨床研修プラクティス」常任編集委員会, 文光堂, 2008 レジデントノート 「ルーティンを見直す！ 病棟指示と頻用薬の使い方」, 羊土社, 2021 Vol.23 No.3" }, { "title": "輸液の基本", "url": "/posts/hydration.html", "categories": "Medicine, Electrolytes", "tags": "", "date": "2021-07-04 00:00:00 +0900", "snippet": "体内の水分分布細胞内液:組織間液:血漿 = 8:3:1。組織間液と血漿の間は自由に行き来ができる 細胞外液は組織間液と血漿に行きわたる (血管内に 1/4 残る) 5% ブドウ糖液は上記のすべてに均等に分布 (血管内に 1/12 残る) アルブミン製剤は血管内にすべて残る各種輸液製剤の組成   Na Cl K 酢/乳 糖 (g/dL) 備考 生理食塩水 154 154       0.9%。NaCl 1g = 17mEq 酢酸リンゲル (ソルアセト F) 131 109 4 2.8   酢酸から - が出るので、Cl は生食より少なめ。Ca も入っているので注意 5 % ブドウ糖液         5   1 号液 (ソルデム 1) 90 70   2.5   生食と 5%Glu を 1:1 で混ぜたもの (電解質は生食の半分になっている) 3 号液 (ソルデム 3) 35 35 20 20 4.3 生食と 5%Glu を 1:3 で混ぜたもの (生食の 1/4) + K ビーフリード 35 35 20 20 7.5 3号液 + アミノ酸 + VitB1 ケース別の輸液救急患者: 外液 80mL/h ショックの時はカリウムフリーで！ 大量投与するときはリンゲルの方がよいといわれている (高 Cl からの尿量減少のおそれあり) 小児のときは異なるので注意。腎不全患者: 1 号液 40mL/h特に GFR 15 未満では注意。食事が摂れない場合: 3 号液 80mL/h 一日に必要なのは水 2000mL, Na 80mEq → 5g, K 40mEq, ブドウ糖 100g 非常に雑だが、普通の人はソル 3 を 2L、脱水があればそれ以上、小柄な高齢者では 1.5L くらいな感じでよい。水分必要量の計算 水分必要量 = 尿量 + 700 (+ 発汗・その他水分喪失) で計算できる。 尿量は 400mL 以下で乏尿、100mL 以下で無尿。普通の人は 1300mL くらい。 NG チューブ、胆道ドレナージ、イレウス管が挿入されている場合や発熱が持続している場合は体液の一日量と電解質組成を上の式の「その他水分喪失」に代入して計算する必要がある。高 Na 血症: 5% ブドウ糖液 80mL/hNa の入っていないものを選びたいという気持ち。血管内にはあんまり入ってくれないが……参考文献 レジデントのためのこれだけ輸液, 佐藤弘明, 日本医事新報社, 2020 内科レジデントの鉄則 第 3 版, 聖路加国際病院内科チーフレジデント, 医学書院, 2018" } ]
